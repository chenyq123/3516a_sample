diff libdetect_t_bak/blackboard_detect.cpp libdetect_t_bak2/blackboard_detect.cpp
4,5c4,5
< BlackboardDetecting::BlackboardDetecting(KVConfig *cfg)
<     : cfg_(cfg),bg_model(NULL, NULL, true)
---
> BlackboardDetecting::BlackboardDetecting(KVConfig *cfg)	
> 	: cfg_(cfg),bg_model(NULL, NULL, true)
7,44c7,44
< 
<     N = 4;
<     buflen = atof(cfg_->get_value("buflen", "3"));;//ÉèÎª2£º±íÊ¾Á¬ĞøÁ½Ö¡Ö®¼ä×öÖ¡²î£»ÉèÎª3£º±íÊ¾¸ôÒ»Ö¡×öÖ¡²î(¸ôÖ¡Ö¡²î±È½ÏÃô¸Ğ)
<     buffer = NULL;
<     diff_threshold_three = atof(cfg_->get_value("diff_threshold_three", "17"));
<     diff_threshold = atof(cfg_->get_value("diff_threshold", "30"));
< 
<     video_width_ = atof(cfg_->get_value("video_width", "960"));
<     video_height_ = atof(cfg_->get_value("video_height", "540"));
< 
<     merge_interval = atof(cfg_->get_value("bg_merge_interval", "30"));
<     min_area = atof(cfg_->get_value("bg_min_area", "3"));
<     max_area = atof(cfg_->get_value("bg_max_area", "10000"));
<     learning_rate = atof(cfg_->get_value("bg_learning_rate", "0.001"));
<     mog_threshold = atof(cfg_->get_value("bg_mog_threshold", "135"));
<     bg_model.set("fTau",atof(cfg_->get_value("bg_fTau", "0.1")));//ÒõÓ°Ïû³ı²ÎÊı£¬0-1Ö®¼ä£¬Ä¬ÈÏÎª0.5£¬Ô½Ğ¡£¬ÒõÓ°Ïû³ıÔ½À÷º¦
<     bg_model.set("varThreshold",atof(cfg_->get_value("bg_varThreshold", "60")));
< 
<     luv_u_max = atoi(cfg_->get_value("bg_luv_u_max", "21"));
<     luv_v_max = atoi(cfg_->get_value("bg_luv_v_max", "21"));
<     luv_u_min = atoi(cfg_->get_value("bg_luv_u_min", "0"));
<     luv_v_min = atoi(cfg_->get_value("bg_luv_v_min", "0"));
<     luv_L = atoi(cfg_->get_value("bg_luv_L", "55"));
< 
<     ismask_ = false;
< 
<     masked_rect = get_rect(cfg_->get_value("calibration_data", "0"),cfg_->get_value("calibration_data_2", "0"));
< 
<     const char*cb_date,*cb_date_2;
<     if(cfg_->get_value("calibration_data", "0"))
<         cb_date = "calibration_data";
<     else
<         cb_date = NULL;
<     if(cfg_->get_value("calibration_data_2", "0"))
<         cb_date_2 = "calibration_data_2";
<     else
<         cb_date_2 = NULL;
<     img_mask_ = build_mask(cb_date,cb_date_2);
---
> 	
> 	N = 4;
> 	buflen = atof(cfg_->get_value("buflen", "3"));;//ÉèÎª2£º±íÊ¾Á¬ĞøÁ½Ö¡Ö®¼ä×öÖ¡²î£»ÉèÎª3£º±íÊ¾¸ôÒ»Ö¡×öÖ¡²î(¸ôÖ¡Ö¡²î±È½ÏÃô¸Ğ)
> 	buffer = NULL;
> 	diff_threshold_three = atof(cfg_->get_value("diff_threshold_three", "17"));
> 	diff_threshold = atof(cfg_->get_value("diff_threshold", "30"));
> 	
> 	video_width_ = atof(cfg_->get_value("video_width", "960"));
> 	video_height_ = atof(cfg_->get_value("video_height", "540"));
> 
> 	merge_interval = atof(cfg_->get_value("bg_merge_interval", "30"));
> 	min_area = atof(cfg_->get_value("bg_min_area", "3"));
> 	max_area = atof(cfg_->get_value("bg_max_area", "10000"));
> 	learning_rate = atof(cfg_->get_value("bg_learning_rate", "0.001"));
> 	mog_threshold = atof(cfg_->get_value("bg_mog_threshold", "135"));
> 	bg_model.set("fTau",atof(cfg_->get_value("bg_fTau", "0.1")));//ÒõÓ°Ïû³ı²ÎÊı£¬0-1Ö®¼ä£¬Ä¬ÈÏÎª0.5£¬Ô½Ğ¡£¬ÒõÓ°Ïû³ıÔ½À÷º¦
> 	bg_model.set("varThreshold",atof(cfg_->get_value("bg_varThreshold", "60")));
> 
> 	luv_u_max = atoi(cfg_->get_value("bg_luv_u_max", "21"));
> 	luv_v_max = atoi(cfg_->get_value("bg_luv_v_max", "21"));
> 	luv_u_min = atoi(cfg_->get_value("bg_luv_u_min", "0"));
> 	luv_v_min = atoi(cfg_->get_value("bg_luv_v_min", "0"));
> 	luv_L = atoi(cfg_->get_value("bg_luv_L", "55"));
> 
> 	ismask_ = false;
> 
> 	masked_rect = get_rect(cfg_->get_value("calibration_data", "0"),cfg_->get_value("calibration_data_2", "0"));
> 
> 	const char*cb_date,*cb_date_2;
> 	if(cfg_->get_value("calibration_data", "0"))
> 		cb_date = "calibration_data";
> 	else
> 		cb_date = NULL;
> 	if(cfg_->get_value("calibration_data_2", "0"))
> 		cb_date_2 = "calibration_data_2";
> 	else
> 		cb_date_2 = NULL;
> 	img_mask_ = build_mask(cb_date,cb_date_2);
54,60c54,60
< //  buffer = (IplImage**)malloc(sizeof(buffer[0])*N);
< //  //buffer = new IplImage*[N];
< //  for(int i = 0;i<N;i++)
< //  {
< //      buffer[i]= cvCreateImage(cvSize(image->width,image->height),IPL_DEPTH_8U,1);
< //      cvSetZero(buffer[i]);
< //  }
---
> //	buffer = (IplImage**)malloc(sizeof(buffer[0])*N);
> //	//buffer = new IplImage*[N];
> //	for(int i = 0;i<N;i++)
> //	{
> //		buffer[i]= cvCreateImage(cvSize(image->width,image->height),IPL_DEPTH_8U,1);
> //		cvSetZero(buffer[i]);
> //	}
68,86c68,86
< //  cvCvtColor(img,buffer[buflen-1],CV_BGR2GRAY);
< //  cvAbsDiff(buffer[buflen-1],buffer[0],silh);
< //  for(int i = 0;i<buflen-1;i++)
< //  {
< //      cvCopy(buffer[i+1],buffer[i]);
< //  }
< //  cvThreshold( silh, silh, diff_threshold, 255, CV_THRESH_BINARY );
< //  cvSmooth(silh,silh,CV_MEDIAN,3,0,0,0);
< //
< //  /*IplImage* pyr=cvCreateImage(cvSize((silh->width&-2)/2,(silh->height&-2)/2),IPL_DEPTH_8U,1);
< //  cvPyrDown(silh,pyr,7);
< //  cvDilate(pyr,pyr,0,1);
< //  cvPyrUp(pyr,silh,7);
< //  cvReleaseImage(&pyr);*/
< //
< //  cv::dilate((Mat)silh, (Mat)silh, cv::Mat());
< //  cv::erode((Mat)silh,(Mat)silh, cv::Mat());
< //  cv::erode((Mat)silh, (Mat)silh, cv::Mat());
< //  cv::dilate((Mat)silh, (Mat)silh, cv::Mat(),cv::Point(-1,-1),2);
---
> //	cvCvtColor(img,buffer[buflen-1],CV_BGR2GRAY);
> //	cvAbsDiff(buffer[buflen-1],buffer[0],silh);
> //	for(int i = 0;i<buflen-1;i++)
> //	{
> //		cvCopy(buffer[i+1],buffer[i]);
> //	}
> //	cvThreshold( silh, silh, diff_threshold, 255, CV_THRESH_BINARY );
> //	cvSmooth(silh,silh,CV_MEDIAN,3,0,0,0);
> //
> //	/*IplImage* pyr=cvCreateImage(cvSize((silh->width&-2)/2,(silh->height&-2)/2),IPL_DEPTH_8U,1);
> //	cvPyrDown(silh,pyr,7);
> //	cvDilate(pyr,pyr,0,1);
> //	cvPyrUp(pyr,silh,7);
> //	cvReleaseImage(&pyr);*/
> //
> //	cv::dilate((Mat)silh, (Mat)silh, cv::Mat());
> //	cv::erode((Mat)silh,(Mat)silh, cv::Mat());   
> //	cv::erode((Mat)silh, (Mat)silh, cv::Mat()); 
> //	cv::dilate((Mat)silh, (Mat)silh, cv::Mat(),cv::Point(-1,-1),2); 
92,93c92,93
< //int BlackboardDetecting::cmp_func_area(const CvRect&a,const CvRect&b)
< //{
---
> //int BlackboardDetecting::cmp_func_area(const CvRect&a,const CvRect&b) 
> //{ 	
95c95
< //  return (a.width*a.height)>(b.width*b.height);
---
> //	return (a.width*a.height)>(b.width*b.height);
104,118c104,118
< //  CvRect rect_new;
< //  int small_x = a.x;
< //  int small_y = a.y;
< //  int big_x = a.x+a.width;
< //  int big_y = a.y+a.height;
< //  if(b.x<small_x)
< //      small_x=b.x;
< //  if(b.y<small_y)
< //      small_y=b.y;
< //  if(b.x+b.width>big_x)
< //      big_x=b.x+b.width;
< //  if(b.y+b.height>big_y)
< //      big_y=b.y+b.height;
< //  rect_new = cvRect(small_x,small_y,big_x-small_x,big_y-small_y);
< //  return rect_new;
---
> //	CvRect rect_new;
> //	int small_x = a.x;
> //	int small_y = a.y;
> //	int big_x = a.x+a.width;
> //	int big_y = a.y+a.height;
> //	if(b.x<small_x)
> //		small_x=b.x;
> //	if(b.y<small_y)
> //		small_y=b.y;
> //	if(b.x+b.width>big_x)
> //		big_x=b.x+b.width;
> //	if(b.y+b.height>big_y)
> //		big_y=b.y+b.height;
> //	rect_new = cvRect(small_x,small_y,big_x-small_x,big_y-small_y);
> //	return rect_new;
126,163c126,163
< //  //¶ÔÔË¶¯¿òÏÈ°´Ãæ»ı´óĞ¡½øĞĞÅÅĞò£¬ÓÉ´óµ½Ğ¡;
< //  std::sort(seq.begin(),seq.end(),cmp_func_area);
< //  CvRect rect_i;
< //  CvRect rect_j;
< //  int num = 0;int interval = merge_interval;
< //  for(;;)
< //  {
< //      std::vector<cv::Rect>::iterator it1;
< //      std::vector<cv::Rect>::iterator it2;
< //      num=0;
< //      for(it1 = seq.begin();it1!= seq.end();)
< //      {
< //          for(it2 = it1+1;it2!= seq.end();)
< //          {
< //              rect_i = *it1;
< //              rect_j = *it2;
< //              if(rect_i.x>(rect_j.x+rect_j.width+interval)||(rect_i.x+rect_i.width+interval)<rect_j.x
< //                  ||rect_i.y>(rect_j.y+rect_j.height+interval)||(rect_i.y+rect_i.height+interval)<rect_j.y)
< //              {
< //                  it2++;
< //                  continue;
< //              }
< //              else//µ±¾ØĞÎ¿òÖ®¼äÓĞ½»¼¯Ê±½øĞĞÈÚºÏ;
< //              {
< //                  *it1 = merge_rect(rect_i,rect_j);
< //                  it2 = seq.erase(it2);
< //                  num++;
< //              }
< //          }
< //          it1++;
< //      }
< //      //µ±ËùÓĞ¾ØĞÎ¿òÖ®¼ä²»¿ÉÔÙÈÚºÏÊ±Í£Ö¹Ñ­»·;
< //      if(num==0)
< //      {
< //          //ÖØĞÂ°´Ãæ»ıÅÅĞò;
< //          std::sort(seq.begin(),seq.end(),cmp_func_area);
< //          break;
< //      }
---
> //	//¶ÔÔË¶¯¿òÏÈ°´Ãæ»ı´óĞ¡½øĞĞÅÅĞò£¬ÓÉ´óµ½Ğ¡;
> //	std::sort(seq.begin(),seq.end(),cmp_func_area);
> //	CvRect rect_i;
> //	CvRect rect_j;
> //	int num = 0;int interval = merge_interval;
> //	for(;;)
> //	{
> //		std::vector<cv::Rect>::iterator it1;
> //		std::vector<cv::Rect>::iterator it2;
> //		num=0;
> //		for(it1 = seq.begin();it1!= seq.end();)
> //		{
> //			for(it2 = it1+1;it2!= seq.end();)
> //			{
> //				rect_i = *it1;
> //				rect_j = *it2;
> //				if(rect_i.x>(rect_j.x+rect_j.width+interval)||(rect_i.x+rect_i.width+interval)<rect_j.x
> //					||rect_i.y>(rect_j.y+rect_j.height+interval)||(rect_i.y+rect_i.height+interval)<rect_j.y)
> //				{
> //					it2++;
> //					continue;
> //				}
> //				else//µ±¾ØĞÎ¿òÖ®¼äÓĞ½»¼¯Ê±½øĞĞÈÚºÏ;
> //				{
> //					*it1 = merge_rect(rect_i,rect_j);
> //					it2 = seq.erase(it2);
> //					num++;
> //				}
> //			}
> //			it1++;
> //		}
> //		//µ±ËùÓĞ¾ØĞÎ¿òÖ®¼ä²»¿ÉÔÙÈÚºÏÊ±Í£Ö¹Ñ­»·;
> //		if(num==0)
> //		{
> //			//ÖØĞÂ°´Ãæ»ıÅÅĞò;
> //			std::sort(seq.begin(),seq.end(),cmp_func_area);
> //			break;
> //		}		
165c165
< //  }
---
> //	}
172c172
< //  bool has_rect = false;
---
> //	bool has_rect = false;
174,215c174,215
< //  CvMemStorage *siln_contours_storage = NULL;
< //  CvSeq *siln_contours_seq=NULL;
< //  if(!siln_contours_storage)
< //  {
< //      siln_contours_storage=cvCreateMemStorage(0);
< //      siln_contours_seq=cvCreateSeq(0,sizeof(CvSeq),sizeof(CvContour),siln_contours_storage);
< //  }
< //  else
< //      cvClearMemStorage(siln_contours_storage);
< //  CvSize size = cvSize(image->width,image->height);
< //  IplImage* silh=NULL;
< //  silh=cvCreateImage(size,IPL_DEPTH_8U,1);
< //  if(!buffer)
< //  {
< //      creat_buffer(image);
< //  }
< //  two_frame_method(image,silh);
< //  cvShowImage("Ö¡²î·¨",silh);
< //  //²éÕÒÂÖÀª;
< //  cvFindContours(silh,siln_contours_storage,&siln_contours_seq,sizeof(CvContour),
< //      CV_RETR_EXTERNAL,CV_CHAIN_APPROX_SIMPLE,cvPoint(0,0));
< //  for(;siln_contours_seq;siln_contours_seq=siln_contours_seq->h_next)
< //  {
< //      CvRect rect = ((CvContour*)siln_contours_seq)->rect;//×ÓÀà×ª»»Îª¸¸ÀàÀı×Ó;
< //      if(rect.x<0||rect.y<0||rect.x+rect.width>image->width||rect.y+rect.height>image->height)
< //          continue;
< //      if(rect.width*rect.height<100)//Ì«Ğ¡µÄ¾ØĞÎ¿òÅÅ³ı;
< //          continue;
< //      rect_vector.push_back(rect);
< //
< //  }
< //  //¶Ô¾ØĞÎ¿ò°´ÕÕÃæ»ı´Ó´óµ½Ğ¡½øĞĞÅÅĞò,²¢½øĞĞÈÚºÏ;
< //  if(rect_vector.size()>1)
< //  {
< //      rect_fusion(rect_vector,image);
< //  }
< //  cvReleaseMemStorage(&siln_contours_storage);
< //  cvReleaseImage(&silh);
< //  if(rect_vector.size()>0)
< //  {
< //      has_rect = true;
< //  }
---
> //	CvMemStorage *siln_contours_storage = NULL;
> //	CvSeq *siln_contours_seq=NULL;
> //	if(!siln_contours_storage)
> //	{
> //		siln_contours_storage=cvCreateMemStorage(0);
> //		siln_contours_seq=cvCreateSeq(0,sizeof(CvSeq),sizeof(CvContour),siln_contours_storage);
> //	}
> //	else
> //		cvClearMemStorage(siln_contours_storage);
> //	CvSize size = cvSize(image->width,image->height);
> //	IplImage* silh=NULL;
> //	silh=cvCreateImage(size,IPL_DEPTH_8U,1);
> //	if(!buffer)
> //	{
> //		creat_buffer(image);
> //	}
> //	two_frame_method(image,silh);
> //	cvShowImage("Ö¡²î·¨",silh);	
> //	//²éÕÒÂÖÀª;
> //	cvFindContours(silh,siln_contours_storage,&siln_contours_seq,sizeof(CvContour),
> //		CV_RETR_EXTERNAL,CV_CHAIN_APPROX_SIMPLE,cvPoint(0,0));
> //	for(;siln_contours_seq;siln_contours_seq=siln_contours_seq->h_next)
> //	{
> //		CvRect rect = ((CvContour*)siln_contours_seq)->rect;//×ÓÀà×ª»»Îª¸¸ÀàÀı×Ó;
> //		if(rect.x<0||rect.y<0||rect.x+rect.width>image->width||rect.y+rect.height>image->height)
> //			continue;
> //		if(rect.width*rect.height<100)//Ì«Ğ¡µÄ¾ØĞÎ¿òÅÅ³ı;
> //			continue;
> //		rect_vector.push_back(rect);
> //
> //	}
> //	//¶Ô¾ØĞÎ¿ò°´ÕÕÃæ»ı´Ó´óµ½Ğ¡½øĞĞÅÅĞò,²¢½øĞĞÈÚºÏ;
> //	if(rect_vector.size()>1)
> //	{
> //		rect_fusion(rect_vector,image);
> //	}
> //	cvReleaseMemStorage(&siln_contours_storage);
> //	cvReleaseImage(&silh);
> //	if(rect_vector.size()>0)
> //	{
> //		has_rect = true;
> //	}
226c226
<     return (a.width * a.height > b.width * b.height);
---
> 	return (a.width * a.height > b.width * b.height);
234,248c234,248
<     Rect rect_new;
<     int small_x = a.x;
<     int small_y = a.y;
<     int big_x = a.x + a.width;
<     int big_y = a.y + a.height;
<     if (b.x < small_x)
<         small_x = b.x;
<     if (b.y < small_y)
<         small_y = b.y;
<     if (b.x + b.width > big_x)
<         big_x = b.x + b.width;
<     if (b.y + b.height > big_y)
<         big_y = b.y + b.height;
<     rect_new = Rect(small_x, small_y, big_x - small_x, big_y - small_y);
<     return rect_new;
---
> 	Rect rect_new;
> 	int small_x = a.x;
> 	int small_y = a.y;
> 	int big_x = a.x + a.width;
> 	int big_y = a.y + a.height;
> 	if (b.x < small_x)
> 		small_x = b.x;
> 	if (b.y < small_y)
> 		small_y = b.y;
> 	if (b.x + b.width > big_x)
> 		big_x = b.x + b.width;
> 	if (b.y + b.height > big_y)
> 		big_y = b.y + b.height;
> 	rect_new = Rect(small_x, small_y, big_x - small_x, big_y - small_y);
> 	return rect_new;
256,293c256,293
<     //¶ÔÔË¶¯¿òÏÈ°´Ãæ»ı´óĞ¡½øĞĞÅÅĞò£¬ÓÉ´óµ½Ğ¡ ;
<     std::sort(seq.begin(), seq.end(), cmp_area);
<     Rect rect_i;
<     Rect rect_j;
<     int num = 0;        //int interval = img.cols*interval_;
<     for (;;) {
<         std::vector < cv::Rect >::iterator it1;
<         std::vector < cv::Rect >::iterator it2;
<         num = 0;
<         for (it1 = seq.begin(); it1 != seq.end();) {
<             for (it2 = it1 + 1; it2 != seq.end();) {
<                 rect_i = *it1;
<                 rect_j = *it2;
<                 if (rect_i.x >
<                     (rect_j.x + rect_j.width + interval)
<                     || (rect_i.x + rect_i.width + interval) <
<                     rect_j.x
<                     || rect_i.y >
<                     (rect_j.y + rect_j.height + interval)
<                     || (rect_i.y + rect_i.height + interval) <
<                     rect_j.y) {
<                     it2++;
<                     continue;
<                 } else  //µ±¾ØĞÎ¿òÖ®¼äÓĞ½»¼¯Ê±½øĞĞÈÚºÏ ;
<                 {
<                     *it1 = sort_rect(rect_i, rect_j);
<                     it2 = seq.erase(it2);
<                     num++;
<                 }
<             }
<             it1++;
<         }
<         //µ±ËùÓĞ¾ØĞÎ¿òÖ®¼ä²»¿ÉÔÙÈÚºÏÊ±Í£Ö¹Ñ­»· ;
<         if (num == 0) {
<             //ÖØĞÂ°´Ãæ»ıÅÅĞò ;
<             std::sort(seq.begin(), seq.end(), cmp_area);
<             break;
<         }
---
> 	//¶ÔÔË¶¯¿òÏÈ°´Ãæ»ı´óĞ¡½øĞĞÅÅĞò£¬ÓÉ´óµ½Ğ¡ ;
> 	std::sort(seq.begin(), seq.end(), cmp_area);
> 	Rect rect_i;
> 	Rect rect_j;
> 	int num = 0;		//int interval = img.cols*interval_;
> 	for (;;) {
> 		std::vector < cv::Rect >::iterator it1;
> 		std::vector < cv::Rect >::iterator it2;
> 		num = 0;
> 		for (it1 = seq.begin(); it1 != seq.end();) {
> 			for (it2 = it1 + 1; it2 != seq.end();) {
> 				rect_i = *it1;
> 				rect_j = *it2;
> 				if (rect_i.x >
> 				    (rect_j.x + rect_j.width + interval)
> 				    || (rect_i.x + rect_i.width + interval) <
> 				    rect_j.x
> 				    || rect_i.y >
> 				    (rect_j.y + rect_j.height + interval)
> 				    || (rect_i.y + rect_i.height + interval) <
> 				    rect_j.y) {
> 					it2++;
> 					continue;
> 				} else	//µ±¾ØĞÎ¿òÖ®¼äÓĞ½»¼¯Ê±½øĞĞÈÚºÏ ;
> 				{
> 					*it1 = sort_rect(rect_i, rect_j);
> 					it2 = seq.erase(it2);
> 					num++;
> 				}
> 			}
> 			it1++;
> 		}
> 		//µ±ËùÓĞ¾ØĞÎ¿òÖ®¼ä²»¿ÉÔÙÈÚºÏÊ±Í£Ö¹Ñ­»· ;
> 		if (num == 0) {
> 			//ÖØĞÂ°´Ãæ»ıÅÅĞò ;
> 			std::sort(seq.begin(), seq.end(), cmp_area);
> 			break;
> 		}
295c295
<     }
---
> 	}
301,302c301,302
<                                Mat & dst,
<                                double interval,double minarea,double maxarea)
---
> 						       Mat & dst,
> 						       double interval,double minarea,double maxarea)
304,337c304,337
<     vector < Rect > rect;
<     int niters = 2;
<     vector < vector < Point > >contours;
<     vector < vector < Point > >contours_temp;
<     vector < Vec4i > hierarchy;
<     vector < Rect > right_rect;
<     Mat temp;
<     /*dilate(mask, temp, Mat(), Point(-1,-1), 1);
<        erode(temp, temp, Mat(), Point(-1,-1), niters);
<        dilate(temp, temp, Mat(), Point(-1,-1), niters); */
< 
<     cv::dilate(mask, temp, cv::Mat());
<     cv::erode(mask, temp, cv::Mat());
<     cv::erode(mask, temp, cv::Mat());
<     cv::dilate(mask, temp, cv::Mat(), cv::Point(-1, -1), 2);
< 
<     //ÕÒ³ö»­³ö³¬¹ıÒ»¶¨Ãæ»ıµÄÁ¬Í¨ÇøÓò ;
<     findContours(temp, contours, hierarchy, CV_RETR_EXTERNAL,
<              CV_CHAIN_APPROX_SIMPLE);
<     dst = Mat::zeros(img.size(), CV_8UC3);
<     if (contours.size() > 0) {
<         Scalar color(255, 255, 255);
<         for (int idx = 0; idx < contours.size(); idx++) {
<             const vector < Point > &c = contours[idx];
<             Rect t = boundingRect(Mat(c));
<             double area = fabs(contourArea(Mat(c)));
<             if (area >= min_area && area<=maxarea)
<             {
<                 contours_temp.push_back(contours[idx]);
<                 right_rect.push_back(t);
<             }
<         }
<         drawContours(dst, contours_temp, -1, color, CV_FILLED, 8);
<     }
---
> 	vector < Rect > rect;
> 	int niters = 2;
> 	vector < vector < Point > >contours;
> 	vector < vector < Point > >contours_temp;
> 	vector < Vec4i > hierarchy;
> 	vector < Rect > right_rect;
> 	Mat temp;
> 	/*dilate(mask, temp, Mat(), Point(-1,-1), 1);
> 	   erode(temp, temp, Mat(), Point(-1,-1), niters);
> 	   dilate(temp, temp, Mat(), Point(-1,-1), niters); */
> 
> 	cv::dilate(mask, temp, cv::Mat());
> 	cv::erode(mask, temp, cv::Mat());
> 	cv::erode(mask, temp, cv::Mat());
> 	cv::dilate(mask, temp, cv::Mat(), cv::Point(-1, -1), 2);
> 
> 	//ÕÒ³ö»­³ö³¬¹ıÒ»¶¨Ãæ»ıµÄÁ¬Í¨ÇøÓò ;
> 	findContours(temp, contours, hierarchy, CV_RETR_EXTERNAL,
> 		     CV_CHAIN_APPROX_SIMPLE);
> 	dst = Mat::zeros(img.size(), CV_8UC3);
> 	if (contours.size() > 0) {
> 		Scalar color(255, 255, 255);
> 		for (int idx = 0; idx < contours.size(); idx++) {
> 			const vector < Point > &c = contours[idx];
> 			Rect t = boundingRect(Mat(c));
> 			double area = fabs(contourArea(Mat(c)));
> 			if (area >= min_area && area<=maxarea)
> 			{
> 				contours_temp.push_back(contours[idx]);
> 				right_rect.push_back(t);
> 			}
> 		}
> 		drawContours(dst, contours_temp, -1, color, CV_FILLED, 8);
> 	}
339,341c339,341
<         rect_fusion2(right_rect, interval);
<     }
<     return right_rect;
---
> 		rect_fusion2(right_rect, interval);
> 	}
> 	return right_rect;
348,394c348,394
<     Mat luv_m,luv_m_temp,fgimg;//±³¾°¼õ³ı;
<     luv_m.create(Size(img.cols, img.rows), CV_8UC1);
<     luv_m.setTo(0);
<     luv_m_temp = img.clone();
<     luv_m_temp.setTo(Scalar::all(255));
<     Mat img_t; Mat bg_t;
<     cvtColor(img, img_t, CV_BGR2YUV);
<     cvtColor(bg, bg_t, CV_BGR2YUV);
<     for (int i = 0; i < img.cols; i++)
<     {
<         for (int j = 0; j < img.rows; j++)
<         {
<             Vec3b bgr1 = img_t.at < Vec3b > (j, i);
<             Vec3b bgr2 = bg_t.at < Vec3b > (j, i);
<             double L =
<                 (abs) (bgr1.val[0] - bgr2.val[0]);
<             double U =
<                 (abs) (bgr1.val[1] - bgr2.val[1]);
<             double V =
<                 (abs) ((bgr1.val[2] - bgr2.val[2]));
<             if ((U >= luv_u_max || V >= luv_v_max)&&(L >= luv_L))
<             {
<                 luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(0,0,0);
<             }
<             else if ((U >= luv_u_max || V >= luv_v_max)&&(L < luv_L))
<             {
<                 luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(0,0,255);
<             }
<             else if ((U < luv_u_max && V < luv_v_max && U > luv_u_min && V > luv_v_min)&&(L > luv_L))
<             {
<                 luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(255,0,0);
<             }
<             else
<             {
<                 luv_m.at < char >(j, i) = 0;
<             }
< 
<         }
<     }
< 
<     r=refineSegments2(img, luv_m, fgimg,merge_interval,min_area,max_area);
<     if(atoi(cfg_->get_value("debug","0"))>0)
<     {
<         //imshow("bg_luv_fgimg",fgimg);
<         imshow("bg_luv_m_temp",luv_m_temp);
<         waitKey(1);
<     }
---
> 	Mat luv_m,luv_m_temp,fgimg;//±³¾°¼õ³ı;
> 	luv_m.create(Size(img.cols, img.rows), CV_8UC1);
> 	luv_m.setTo(0);
> 	luv_m_temp = img.clone();
> 	luv_m_temp.setTo(Scalar::all(255));
> 	Mat img_t; Mat bg_t;
> 	cvtColor(img, img_t, CV_BGR2YUV);
> 	cvtColor(bg, bg_t, CV_BGR2YUV);
> 	for (int i = 0; i < img.cols; i++) 
> 	{
> 		for (int j = 0; j < img.rows; j++) 
> 		{
> 			Vec3b bgr1 = img_t.at < Vec3b > (j, i);
> 			Vec3b bgr2 = bg_t.at < Vec3b > (j, i);
> 			double L =
> 				(abs) (bgr1.val[0] - bgr2.val[0]);
> 			double U =
> 				(abs) (bgr1.val[1] - bgr2.val[1]);
> 			double V =
> 				(abs) ((bgr1.val[2] - bgr2.val[2]));
> 			if ((U >= luv_u_max || V >= luv_v_max)&&(L >= luv_L))
> 			{
> 				luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(0,0,0);
> 			}
> 			else if ((U >= luv_u_max || V >= luv_v_max)&&(L < luv_L))
> 			{
> 				luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(0,0,255);
> 			}
> 			else if ((U < luv_u_max && V < luv_v_max && U > luv_u_min && V > luv_v_min)&&(L > luv_L))
> 			{
> 				luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(255,0,0);
> 			}
> 			else
> 			{
> 				luv_m.at < char >(j, i) = 0;
> 			}
> 		   
> 		}
> 	}
> 
> 	r=refineSegments2(img, luv_m, fgimg,merge_interval,min_area,max_area);
> 	if(atoi(cfg_->get_value("debug","0"))>0)
> 	{
> 		//imshow("bg_luv_fgimg",fgimg);
> 		imshow("bg_luv_m_temp",luv_m_temp);
> 		waitKey(1);
> 	}
402,417c402,417
<     bool has_rect = false;
<     Mat fgmask;
<     bg_model(img, fgmask, learning_rate);   //update_bg_model ? -1 : 0
<     Mat bg;//»ñµÃµÄ±³¾°Í¼Ïñ
<     bg_model.getBackgroundImage(bg);
<     if (atoi(cfg_->get_value("debug", "0")) > 0)
<     {
<         imshow("bg_background image", bg);
<         waitKey(1);
<     }
<     luv_method(img,bg,r);
<     if(r.size()>0)
<     {
<         has_rect = true;
<     }
<     return has_rect;
---
> 	bool has_rect = false;
> 	Mat fgmask;
> 	bg_model(img, fgmask, learning_rate);	//update_bg_model ? -1 : 0
> 	Mat bg;//»ñµÃµÄ±³¾°Í¼Ïñ
> 	bg_model.getBackgroundImage(bg);
> 	if (atoi(cfg_->get_value("debug", "0")) > 0)
> 	{
> 	    imshow("bg_background image", bg);
> 	    waitKey(1);
> 	}
> 	luv_method(img,bg,r);
> 	if(r.size()>0)
> 	{
> 		has_rect = true;
> 	}
> 	return has_rect;
426,455c426,455
<     bool masked = false;
<     const char *pts = cfg_->get_value(key, "0");
<     std::vector < Point > points;
<     if (pts) {
<         char *data = strdup(pts);
<         char *p = strtok(data, ";");
<         while (p) {
<             // Ã¿¸öPoint Ê¹"x,y" ¸ñÊ½ ;
<             int x, y;
<             if (sscanf(p, "%d,%d", &x, &y) == 2) {
<                 CvPoint pt = { x, y };
<                 pt.x = pt.x-masked_rect.x; pt.y = pt.y-masked_rect.y;//++++++++++++++++;
<                 points.push_back(pt);
<             }
< 
<             p = strtok(0, ";");
<         }
<         free(data);
<     }
< 
<     if (points.size() > 3) {
<         int n = points.size();
<         const Point **pts =
<             (const Point **) alloca(sizeof(const Point *) * points.size());
<         for (int i = 0; i < n; i++) {
<             pts[i] = &points[i];
<         }
<         fillPoly(img, pts, &n, 1, CV_RGB(255, 255, 255));
<         masked = true;
<     }
---
> 	bool masked = false;
> 	const char *pts = cfg_->get_value(key, "0");
> 	std::vector < Point > points;
> 	if (pts) {
> 		char *data = strdup(pts);
> 		char *p = strtok(data, ";");
> 		while (p) {
> 			// Ã¿¸öPoint Ê¹"x,y" ¸ñÊ½ ;
> 			int x, y;
> 			if (sscanf(p, "%d,%d", &x, &y) == 2) {
> 				CvPoint pt = { x, y };
> 				pt.x = pt.x-masked_rect.x; pt.y = pt.y-masked_rect.y;//++++++++++++++++;
> 				points.push_back(pt);
> 			}
> 
> 			p = strtok(0, ";");
> 		}
> 		free(data);
> 	}
> 
> 	if (points.size() > 3) {
> 		int n = points.size();
> 		const Point **pts =
> 		    (const Point **) alloca(sizeof(const Point *) * points.size());
> 		for (int i = 0; i < n; i++) {
> 			pts[i] = &points[i];
> 		}
> 		fillPoly(img, pts, &n, 1, CV_RGB(255, 255, 255));
> 		masked = true;
> 	}
457c457
<     return masked;
---
> 	return masked;
463,465c463,465
<     /** ´Ó cfg ÖĞµÄ²ÎÊı£¬´´½¨ mask */
<     CvSize size = {masked_rect.width, masked_rect.height};
<     Mat img; img.create(size,CV_8UC3);
---
> 	/** ´Ó cfg ÖĞµÄ²ÎÊı£¬´´½¨ mask */
> 	CvSize size = {masked_rect.width, masked_rect.height};
> 	Mat img; img.create(size,CV_8UC3);
467,468c467,468
<     if (!ismask_)
<         img.setTo(0);
---
> 	if (!ismask_)
> 		img.setTo(0);
470,472c470,472
<     if (key) {
<         ismask_ = build_mask_internal(key, img);
<     }
---
> 	if (key) {
> 		ismask_ = build_mask_internal(key, img);
> 	}
474,477c474,477
<     if (key2) {
<         build_mask_internal(key2, img);
<     }
<     return img;
---
> 	if (key2) {
> 		build_mask_internal(key2, img);
> 	}
> 	return img;
480c480
< //ÊäÈëÔ­Ê¼Í¼Ïñ£¬·µ»ØÑÚÂëºóµÄÍ¼Ïñ;
---
> //ÊäÈëÔ­Ê¼Í¼Ïñ£¬·µ»ØÑÚÂëºóµÄÍ¼Ïñ; 
483,486c483,486
<     if (ismask_)        //ÊÇ·ñÌî³äÍê±Ï ;
<     {
<         bitwise_and(img, img_mask_, img);
<     }
---
> 	if (ismask_)		//ÊÇ·ñÌî³äÍê±Ï ;
> 	{
> 		bitwise_and(img, img_mask_, img);
> 	} 
492c492
< //  bool masked = false;
---
> //	bool masked = false;
494,495c494,495
< //  const char *pts = cfg_->get_value(key, "0");
< //  std::vector < Point > points;
---
> //	const char *pts = cfg_->get_value(key, "0");
> //	std::vector < Point > points;
497,522c497,522
< //  if (pts) {
< //      char *data = strdup(pts);
< //      char *p = strtok(data, ";");
< //      while (p) {
< //          // Ã¿¸öPoint Ê¹"x,y" ¸ñÊ½ ;
< //          int x, y;
< //          if (sscanf(p, "%d,%d", &x, &y) == 2) {
< //              CvPoint pt = { x, y };
< //              points.push_back(pt);
< //          }
< //
< //          p = strtok(0, ";");
< //      }
< //      free(data);
< //  }
< //
< //  if (points.size() > 3) {
< //      int n = points.size();
< //      const Point **pts =
< //          (const Point **) alloca(sizeof(const Point *) * points.size());
< //      for (int i = 0; i < n; i++) {
< //          pts[i] = &points[i];
< //      }
< //      fillPoly(img, pts, &n, 1, CV_RGB(255, 255, 255));
< //      masked = true;
< //  }
---
> //	if (pts) {
> //		char *data = strdup(pts);
> //		char *p = strtok(data, ";");
> //		while (p) {
> //			// Ã¿¸öPoint Ê¹"x,y" ¸ñÊ½ ;
> //			int x, y;
> //			if (sscanf(p, "%d,%d", &x, &y) == 2) {
> //				CvPoint pt = { x, y };
> //				points.push_back(pt);
> //			}
> //
> //			p = strtok(0, ";");
> //		}
> //		free(data);
> //	}
> //
> //	if (points.size() > 3) {
> //		int n = points.size();
> //		const Point **pts =
> //		    (const Point **) alloca(sizeof(const Point *) * points.size());
> //		for (int i = 0; i < n; i++) {
> //			pts[i] = &points[i];
> //		}
> //		fillPoly(img, pts, &n, 1, CV_RGB(255, 255, 255));
> //		masked = true;
> //	}
524c524
< //  return masked;
---
> //	return masked;
530,545c530,545
< //  /** ´Ó cfg ÖĞµÄ²ÎÊı£¬´´½¨ mask */
< //  //CvSize size = {video_width_, video_height_};
< //  Size size(video_width_, video_height_);
< //  Mat img; img.create(size,CV_8UC3);
< //
< //  if (!ismask_)
< //      img.setTo(0);
< //
< //  if (key) {
< //      ismask_ = build_mask_internal(key, img);
< //  }
< //
< //  if (key2) {
< //      build_mask_internal(key2, img);
< //  }
< //  return img;
---
> //	/** ´Ó cfg ÖĞµÄ²ÎÊı£¬´´½¨ mask */
> //	//CvSize size = {video_width_, video_height_};
> //	Size size(video_width_, video_height_);
> //	Mat img; img.create(size,CV_8UC3);
> //
> //	if (!ismask_)
> //		img.setTo(0);
> //
> //	if (key) {
> //		ismask_ = build_mask_internal(key, img);
> //	}
> //
> //	if (key2) {
> //		build_mask_internal(key2, img);
> //	}
> //	return img;
548c548
< ////ÊäÈëÔ­Ê¼Í¼Ïñ£¬·µ»ØÑÚÂëºóµÄÍ¼Ïñ;
---
> ////ÊäÈëÔ­Ê¼Í¼Ïñ£¬·µ»ØÑÚÂëºóµÄÍ¼Ïñ; 
551,554c551,554
< //  if (ismask_)        //ÊÇ·ñÌî³äÍê±Ï ;
< //  {
< //      bitwise_and(img, img_mask_, img);
< //  }
---
> //	if (ismask_)		//ÊÇ·ñÌî³äÍê±Ï ;
> //	{
> //		bitwise_and(img, img_mask_, img);
> //	} 
560,587c560,587
<     std::vector<cv::Point> points;
<     /*if (!pts) {
<         points.push_back(cv::Point(0, 0));
<         points.push_back(cv::Point(0, atoi(cfg_->get_value("video_width", "960"))));
<         points.push_back(cv::Point(atoi(cfg_->get_value("video_width", "960")),
<             atoi(cfg_->get_value("video_height", "540"))));
<         points.push_back(cv::Point(atoi(cfg_->get_value("video_width", "960")), 0));
<         return points;
<     }*/
<     char key[64];
<     if (pts)
<     {
<         char *data = strdup(pts);
<         char *p = strtok(data, ";");
<         while (p)
<         {
<             // Ã¿¸öPoint Ê¹"x,y" ¸ñÊ½;
<             int x, y;
<             if (sscanf(p, "%d,%d", &x, &y) == 2)
<             {
<                 CvPoint pt = { x, y };
<                 points.push_back(pt);
<             }
< 
<             p = strtok(0, ";");
<         }
<         free(data);
<     }
---
> 	std::vector<cv::Point> points;
> 	/*if (!pts) {
> 		points.push_back(cv::Point(0, 0));
> 		points.push_back(cv::Point(0, atoi(cfg_->get_value("video_width", "960"))));
> 		points.push_back(cv::Point(atoi(cfg_->get_value("video_width", "960")), 
> 			atoi(cfg_->get_value("video_height", "540"))));
> 		points.push_back(cv::Point(atoi(cfg_->get_value("video_width", "960")), 0));
> 		return points;
> 	}*/
> 	char key[64];
> 	if (pts) 
> 	{
> 		char *data = strdup(pts);
> 		char *p = strtok(data, ";");
> 		while (p) 
> 		{
> 			// Ã¿¸öPoint Ê¹"x,y" ¸ñÊ½;
> 			int x, y;
> 			if (sscanf(p, "%d,%d", &x, &y) == 2) 
> 			{
> 				CvPoint pt = { x, y };
> 				points.push_back(pt);
> 			}
> 
> 			p = strtok(0, ";");
> 		}
> 		free(data);
> 	}
589c589
<     return points;
---
> 	return points;
595c595
<     return (a.x < b.x);
---
> 	return (a.x < b.x);
602c602
<     return (a.y < b.y);
---
> 	return (a.y < b.y);
609,620c609,620
<     cv::Rect rect;
<     int min_x,min_y;
<     int max_x,max_y;
<     std::sort(pt.begin(), pt.end(), cmp_min_x);
<     min_x = pt[0].x;
<     max_x = pt[pt.size()-1].x;
<     std::sort(pt.begin(), pt.end(), cmp_min_y);
<     min_y = pt[0].y;
<     max_y = pt[pt.size()-1].y;
<     rect = Rect(min_x,min_y,(max_x-min_x),(max_y-min_y));
<     rect &= Rect(0,0,video_width_,video_height_);
<     return rect;
---
> 	cv::Rect rect;
> 	int min_x,min_y;
> 	int max_x,max_y;
> 	std::sort(pt.begin(), pt.end(), cmp_min_x);
> 	min_x = pt[0].x;
> 	max_x = pt[pt.size()-1].x;
> 	std::sort(pt.begin(), pt.end(), cmp_min_y);
> 	min_y = pt[0].y;
> 	max_y = pt[pt.size()-1].y;
> 	rect = Rect(min_x,min_y,(max_x-min_x),(max_y-min_y));
> 	rect &= Rect(0,0,video_width_,video_height_);
> 	return rect;
626,663c626,663
<     Rect masked;
<     std::vector<cv::Point> pt_vector,pt_vector_1,pt_vector_2;
<     if(cb_date)
<     {
<         pt_vector_1 = load_roi(cb_date);
<         if(pt_vector_1.size()>2)
<         {
<             cv::Rect rect1 = get_point_rect(pt_vector_1);
<             masked_rect_vec.push_back(rect1);
<             for(int i = 0;i<pt_vector_1.size();i++)
<             {
<                 pt_vector.push_back(pt_vector_1[i]);
<             }
<         }
<     }
<     if(cb_date_2)
<     {
<         pt_vector_2 = load_roi(cb_date_2);
<         if(pt_vector_2.size()>2)
<         {
<             cv::Rect rect2 = get_point_rect(pt_vector_2);
<             masked_rect_vec.push_back(rect2);
<             for(int i = 0;i<pt_vector_2.size();i++)
<             {
<                 pt_vector.push_back(pt_vector_2[i]);
<             }
<         }
<     }
<     if(pt_vector_1.size()<3 && pt_vector_2.size()<3)
<     {
<         masked = Rect(0,0,atoi(cfg_->get_value("video_width", "960")),atoi(cfg_->get_value("video_height", "540")));
<     }
<     else
<     {
<         masked = get_point_rect(pt_vector);
<     }
<     return masked;
< }
---
> 	Rect masked;
> 	std::vector<cv::Point> pt_vector,pt_vector_1,pt_vector_2;
> 	if(cb_date) 
> 	{
> 		pt_vector_1 = load_roi(cb_date);
> 		if(pt_vector_1.size()>2) 
> 		{
> 			cv::Rect rect1 = get_point_rect(pt_vector_1);
> 			masked_rect_vec.push_back(rect1);
> 			for(int i = 0;i<pt_vector_1.size();i++)
> 			{
> 				pt_vector.push_back(pt_vector_1[i]);
> 			}
> 		}
> 	}	
> 	if(cb_date_2)
> 	{
> 		pt_vector_2 = load_roi(cb_date_2);
> 		if(pt_vector_2.size()>2) 
> 		{
> 			cv::Rect rect2 = get_point_rect(pt_vector_2);
> 			masked_rect_vec.push_back(rect2);
> 			for(int i = 0;i<pt_vector_2.size();i++)
> 			{
> 				pt_vector.push_back(pt_vector_2[i]);
> 			}
> 		}
> 	}	
> 	if(pt_vector_1.size()<3 && pt_vector_2.size()<3)
> 	{
> 		masked = Rect(0,0,atoi(cfg_->get_value("video_width", "960")),atoi(cfg_->get_value("video_height", "540")));
> 	}
> 	else
> 	{
> 		masked = get_point_rect(pt_vector);
> 	}
> 	return masked;
> }
\ æ–‡ä»¶å°¾æ²¡æœ‰ newline å­—ç¬¦
diff libdetect_t_bak/blackboard_detect.h libdetect_t_bak2/blackboard_detect.h
5c5
< #include<opencv2/opencv1.hpp>
---
> #include<opencv2/opencv.hpp>
7,8c7
< #include "KVConfig.h"
< #include <cstdio>
---
> #include "../libkvconfig/KVConfig.h"
16,70c15,69
<     public:
<     BlackboardDetecting(KVConfig *cfg);
<     ~BlackboardDetecting(void);
<     double  diff_threshold_three;
<     double  diff_threshold;
<     int N;//ÈıÖ¡²î·Ö·¨ÖĞbufferÖĞµÄ¸öÊı;
<     int buflen;//Ë«Ö¡²î·Ö·¨ÖĞbufferÖĞµÄ¸öÊı;
<     IplImage **buffer;
<     KVConfig *cfg_;
< 
<     int luv_u_max;
<     int luv_v_max;
<     int luv_u_min;
<     int luv_v_min;
<     int luv_L;
< 
<     double merge_interval;
<     double min_area;
<     double max_area;
< 
<     BackgroundSubtractorMOG2 bg_model;
<     double learning_rate;
<     double mog_threshold;
< 
<     bool ismask_;
<     Mat img_mask_;
<     int video_width_;
<     int video_height_;
< 
<     bool frame_difference_method (IplImage *image,std::vector<cv::Rect> &rect_vector);
<     //IplImage *do_mask(const IplImage *img);
<     void do_mask( Mat &img);
<     cv::Rect masked_rect;
<     std::vector<Rect> masked_rect_vec;
< 
<     std::vector < Rect > refineSegments2(Mat img, Mat & mask, Mat & dst,double interval,double minarea,double maxarea);
<     void rect_fusion2(vector < Rect > &seq, double interval);
<     Rect sort_rect(Rect a, Rect b);
<     static int cmp_area(const Rect & a, const Rect & b);
<     bool one_frame_bd( Mat img, vector < Rect > &r);
< 
< 
<     void two_frame_method(IplImage*img,IplImage*silh);
<     static int cmp_func_area(const CvRect&a,const CvRect&b);
<     CvRect merge_rect(CvRect a,CvRect b);
<     void rect_fusion(std::vector<cv::Rect> &seq,IplImage *image);
<     void creat_buffer(IplImage *image);
< 
<     bool build_mask_internal(const char *key, Mat& img);
<     Mat build_mask(const char *key,const char *key2 = 0);
<     std::vector<cv::Point> load_roi(const char *pts);
<     static int cmp_min_x(const Point & a, const Point & b);
<     static int cmp_min_y(const Point & a, const Point & b);
<     cv::Rect get_point_rect(std::vector<cv::Point> pt);
<     cv::Rect get_rect(const char* pt1,const char* pt2);
---
> 	public:
> 	BlackboardDetecting(KVConfig *cfg);
> 	~BlackboardDetecting(void);
> 	double  diff_threshold_three;
> 	double  diff_threshold;
> 	int N;//ÈıÖ¡²î·Ö·¨ÖĞbufferÖĞµÄ¸öÊı;
> 	int buflen;//Ë«Ö¡²î·Ö·¨ÖĞbufferÖĞµÄ¸öÊı;
> 	IplImage **buffer;
> 	KVConfig *cfg_;
> 
> 	int luv_u_max;
> 	int luv_v_max;
> 	int luv_u_min;
> 	int luv_v_min;
> 	int luv_L;
> 
> 	double merge_interval;
> 	double min_area;
> 	double max_area;
> 
> 	BackgroundSubtractorMOG2 bg_model;
> 	double learning_rate;
> 	double mog_threshold;
> 
> 	bool ismask_;
> 	Mat img_mask_;
> 	int video_width_;
> 	int video_height_;
> 
> 	bool frame_difference_method (IplImage *image,std::vector<cv::Rect> &rect_vector);
> 	//IplImage *do_mask(const IplImage *img);
> 	void do_mask( Mat &img);
> 	cv::Rect masked_rect;
> 	std::vector<Rect> masked_rect_vec;
> 
> 	std::vector < Rect > refineSegments2(Mat img, Mat & mask, Mat & dst,double interval,double minarea,double maxarea);
> 	void BlackboardDetecting::rect_fusion2(vector < Rect > &seq, double interval);
> 	Rect BlackboardDetecting::sort_rect(Rect a, Rect b);
> 	static int BlackboardDetecting::cmp_area(const Rect & a, const Rect & b);
> 	bool BlackboardDetecting::one_frame_bd( Mat img, vector < Rect > &r);
> 
> 
> 	void two_frame_method(IplImage*img,IplImage*silh);
> 	static int cmp_func_area(const CvRect&a,const CvRect&b);
> 	CvRect merge_rect(CvRect a,CvRect b);
> 	void rect_fusion(std::vector<cv::Rect> &seq,IplImage *image);
> 	void creat_buffer(IplImage *image);
> 
> 	bool build_mask_internal(const char *key, Mat& img);
> 	Mat build_mask(const char *key,const char *key2 = 0);
> 	std::vector<cv::Point> load_roi(const char *pts);
> 	static int cmp_min_x(const Point & a, const Point & b);
> 	static int cmp_min_y(const Point & a, const Point & b);
> 	cv::Rect get_point_rect(std::vector<cv::Point> pt);
> 	cv::Rect get_rect(const char* pt1,const char* pt2);
73c72
<     void luv_method(const Mat &img,Mat bg ,std::vector<Rect> &r);
---
> 	void luv_method(const Mat &img,Mat bg ,std::vector<Rect> &r);
76c75
< #endif
---
> #endif
\ æ–‡ä»¶å°¾æ²¡æœ‰ newline å­—ç¬¦
åªåœ¨ libdetect_t_bak å­˜åœ¨ï¼šblackboard_detect.o
diff libdetect_t_bak/camshift.cpp libdetect_t_bak2/camshift.cpp
84c84
< 		//throw std::runtime_error("Can't find the hist file\n");
---
> 		throw std::runtime_error("Can't find the hist file\n");
diff libdetect_t_bak/camshift.h libdetect_t_bak2/camshift.h
3,5c3
< #include <opencv2/opencv1.hpp>
< #include <cstdio>
< #include <iostream>
---
> #include <opencv2/opencv.hpp>
19c17
< 	tracker_camshift(const char* yaml_file);
---
> 	tracker_camshift(const char* yaml_file);	
27c25
< 	bool cam_shift_init_once(cv::Rect &face,cv::Mat image);
---
> 	bool tracker_camshift::cam_shift_init_once(cv::Rect &face,cv::Mat image);
åªåœ¨ libdetect_t_bak å­˜åœ¨ï¼šcamshift.o
diff libdetect_t_bak/ct.cpp libdetect_t_bak2/ct.cpp
26,33c26,33
< //Í¨¹ı»ı·ÖÍ¼À´¼ÆËã²É¼¯µ½µÄÃ¿Ò»¸öÑù±¾µÄharrÌØÕ÷£¬Õâ¸öÌØÕ÷Í¨¹ıÓëfeaturesWeightÀ´Ïà³Ë
< //¾ÍÏàµ±ÓÚÍ¶Ó°µ½Ëæ»ú²âÁ¿¾ØÕóÖĞÁË£¬Ò²¾ÍÊÇ½øĞĞÏ¡Êè±í´ïÁË¡£ÕâÀï²»Ã÷°×µÄ»°£¬¿ÉÒÔ¿´ÏÂ
< //ÂÛÎÄÖĞµÄÍ¼¶ş£¬¾Í±È½ÏÖ±¹ÛÁË¡£
< //»¹ÓĞÒ»µã£ºÊµ¼ÊÉÏÕâÀï²ÉÓÃµÄ²»ÊôÓÚÕæÕıµÄharrÌØÕ÷£¬ÎÒ²©¿ÍÖĞ·­ÒëÓĞÎó¡£ÕâÀï¼ÆËãµÄÊÇ
< //ÔÚboxÖĞ²ÉÑùµÃµ½µÄ²»Í¬¾ØĞÎ¿òµÄ»Ò¶È¼ÓÈ¨ÇóºÍ£¨µ±È¨ÖØÊÇ¸ºÊıµÄÊ±ºò¾ÍÊÇ»Ò¶È²î£©
< //µ±ÎªÁË±íÊö·½±ã£¬ÎÒÏÂÃæ¶¼ÓÃharrÌØÕ÷À´ÃèÊö¡£
< //Ã¿Ò»¸öÑù±¾ÓĞ50¸öharrÌØÕ÷£¬Ã¿Ò»¸öharrÌØÕ÷ÊÇÓÉ2µ½3¸öËæ»úÑ¡ÔñµÄ¾ØĞÎ¿òÀ´¹¹³ÉµÄ£¬
< //¶ÔÕâĞ©¾ØĞÎ¿òµÄ»Ò¶È¼ÓÈ¨ÇóºÍ×÷ÎªÕâÒ»¸öharrÌØÕ÷µÄÌØÕ÷Öµ¡£
---
> //Í¨¹ı»ı·ÖÍ¼À´¼ÆËã²É¼¯µ½µÄÃ¿Ò»¸öÑù±¾µÄharrÌØÕ÷£¬Õâ¸öÌØÕ÷Í¨¹ıÓëfeaturesWeightÀ´Ïà³Ë  
> //¾ÍÏàµ±ÓÚÍ¶Ó°µ½Ëæ»ú²âÁ¿¾ØÕóÖĞÁË£¬Ò²¾ÍÊÇ½øĞĞÏ¡Êè±í´ïÁË¡£ÕâÀï²»Ã÷°×µÄ»°£¬¿ÉÒÔ¿´ÏÂ  
> //ÂÛÎÄÖĞµÄÍ¼¶ş£¬¾Í±È½ÏÖ±¹ÛÁË¡£  
> //»¹ÓĞÒ»µã£ºÊµ¼ÊÉÏÕâÀï²ÉÓÃµÄ²»ÊôÓÚÕæÕıµÄharrÌØÕ÷£¬ÎÒ²©¿ÍÖĞ·­ÒëÓĞÎó¡£ÕâÀï¼ÆËãµÄÊÇ  
> //ÔÚboxÖĞ²ÉÑùµÃµ½µÄ²»Í¬¾ØĞÎ¿òµÄ»Ò¶È¼ÓÈ¨ÇóºÍ£¨µ±È¨ÖØÊÇ¸ºÊıµÄÊ±ºò¾ÍÊÇ»Ò¶È²î£©  
> //µ±ÎªÁË±íÊö·½±ã£¬ÎÒÏÂÃæ¶¼ÓÃharrÌØÕ÷À´ÃèÊö¡£  
> //Ã¿Ò»¸öÑù±¾ÓĞ50¸öharrÌØÕ÷£¬Ã¿Ò»¸öharrÌØÕ÷ÊÇÓÉ2µ½3¸öËæ»úÑ¡ÔñµÄ¾ØĞÎ¿òÀ´¹¹³ÉµÄ£¬  
> //¶ÔÕâĞ©¾ØĞÎ¿òµÄ»Ò¶È¼ÓÈ¨ÇóºÍ×÷ÎªÕâÒ»¸öharrÌØÕ÷µÄÌØÕ÷Öµ¡£ 
48c48
< 	//_numFeatureÊÇÒ»¸öÑù±¾boxµÄharrÌØÕ÷¸öÊı£¬¹²50¸ö¡£¶øÉÏÃæËµµ½£¬
---
> 	//_numFeatureÊÇÒ»¸öÑù±¾boxµÄharrÌØÕ÷¸öÊı£¬¹²50¸ö¡£¶øÉÏÃæËµµ½£¬  
50c50
< 	features = vector<vector<Rect> >(_numFeature, vector<Rect>());
---
> 	features = vector<vector<Rect>>(_numFeature, vector<Rect>());
52,56c52,56
< 	//Ã¿Ò»¸ö·´Ó¦ÌØÕ÷µÄ¾ØĞÎ¿ò¶ÔÓ¦ÓÚÒ»¸öÈ¨ÖØ£¬Êµ¼ÊÉÏ¾ÍÊÇËæ»ú²âÁ¿¾ØÕóÖĞÏàÓ¦µÄÔªËØ£¬ÓÃËüÀ´Óë¶ÔÓ¦µÄÌØÕ÷
< 	//Ïà³Ë£¬±íÊ¾ÒÔÈ¨ÖØµÄ³Ì¶ÈÀ´¸ĞÖªÕâ¸öÌØÕ÷¡£»»¾ä»°Ëµ£¬featuresWeight¾ÍÊÇËæ»ú²âÁ¿¾ØÕó¡£
< 	//Õâ¸ö¾ØÕóµÄÔªËØµÄ¸³Öµ¿´ÂÛÎÄÖĞµÄµÚ¶ş²¿·Ö¡£»òÕßÒ²¿ÉÒÔ²Î¿¼ÏÂÎÒµÄ²©ÎÄ£º£¨ºÇºÇ£¬ºÃÏñ²©ÎÄÒ²Ã»ËµÇå³ş£©
< 	//http://blog.csdn.net/zouxy09/article/details/8118360
< 	featuresWeight = vector<vector<float> >(_numFeature, vector<float>());
---
> 	//Ã¿Ò»¸ö·´Ó¦ÌØÕ÷µÄ¾ØĞÎ¿ò¶ÔÓ¦ÓÚÒ»¸öÈ¨ÖØ£¬Êµ¼ÊÉÏ¾ÍÊÇËæ»ú²âÁ¿¾ØÕóÖĞÏàÓ¦µÄÔªËØ£¬ÓÃËüÀ´Óë¶ÔÓ¦µÄÌØÕ÷  
> 	//Ïà³Ë£¬±íÊ¾ÒÔÈ¨ÖØµÄ³Ì¶ÈÀ´¸ĞÖªÕâ¸öÌØÕ÷¡£»»¾ä»°Ëµ£¬featuresWeight¾ÍÊÇËæ»ú²âÁ¿¾ØÕó¡£  
> 	//Õâ¸ö¾ØÕóµÄÔªËØµÄ¸³Öµ¿´ÂÛÎÄÖĞµÄµÚ¶ş²¿·Ö¡£»òÕßÒ²¿ÉÒÔ²Î¿¼ÏÂÎÒµÄ²©ÎÄ£º£¨ºÇºÇ£¬ºÃÏñ²©ÎÄÒ²Ã»ËµÇå³ş£©  
> 	//http://blog.csdn.net/zouxy09/article/details/8118360  
> 	featuresWeight = vector<vector<float>>(_numFeature, vector<float>());
58,59c58,59
< 	//numRectÊÇÃ¿¸öÌØÕ÷µÄ¾ØĞÎ¿ò¸öÊı»¹ÊÇÂÛÎÄÖĞËµµÄËæ»ú²âÁ¿¾ØÕóÖĞµÄs£¿»¹ÓĞ¼æ±¸Á½ÖÖ¹¦ÄÜ£¿
< 	//ÂÛÎÄÖĞËµsÈ¡2»òÕß3Ê±£¬¾ØÕó¾ÍÂú×ãJohnson-LindenstraussÍÆÂÛ¡£
---
> 	//numRectÊÇÃ¿¸öÌØÕ÷µÄ¾ØĞÎ¿ò¸öÊı»¹ÊÇÂÛÎÄÖĞËµµÄËæ»ú²âÁ¿¾ØÕóÖĞµÄs£¿»¹ÓĞ¼æ±¸Á½ÖÖ¹¦ÄÜ£¿  
> 	//ÂÛÎÄÖĞËµsÈ¡2»òÕß3Ê±£¬¾ØÕó¾ÍÂú×ãJohnson-LindenstraussÍÆÂÛ¡£  
64c64
< 
---
>       
67,71c67,71
< 		//ÈçºÎÉú³É·ş´ÓÄ³¸ö¸ÅÂÊ·Ö²¼µÄËæ»úÊı£¨»òÕßËµ sample£©µÄÎÊÌâ¡£
< 		//±ÈÈç£¬ÄãÏëÒª´ÓÒ»¸ö·ş´ÓÕıÌ¬·Ö²¼µÄËæ»ú±äÁ¿µÃµ½ 100 ¸öÑù±¾£¬ÄÇÃ´¿Ï¶¨³éµ½½Ó½üÆä¾ùÖµµÄÑù±¾µÄ
< 		//¸ÅÂÊÒª´óĞí¶à£¬´Ó¶øµ¼ÖÂ³éµ½µÄÑù±¾ºÜ¶àÊÇ¼¯ÖĞÔÚÄÇ¸½½üµÄ¡£
< 		//rng.uniform()·µ»ØÒ»¸ö´Ó[ 1£¬2£©·¶Î§¾ùÔÈ²ÉÑùµÄËæ»úÊı£¬¼´ÔÚ[ 1£¬2£©ÄÚ·ş´Ó¾ùÔÈ·Ö²¼£¨È¡²»Í¬Öµ¸ÅÂÊÏàÍ¬£©
< 		//ÄÇÃ´ÏÂÃæµÄ¹¦ÄÜ¾ÍÊÇµÃµ½[2£¬4£©·¶Î§µÄËæ»úÊı£¬È»ºóÓÃcvFloor·µ»Ø²»´óÓÚ²ÎÊıµÄ×î´óÕûÊıÖµ£¬ÄÇÒªÃ´ÊÇ2£¬ÒªÃ´ÊÇ3¡£
---
> 		//ÈçºÎÉú³É·ş´ÓÄ³¸ö¸ÅÂÊ·Ö²¼µÄËæ»úÊı£¨»òÕßËµ sample£©µÄÎÊÌâ¡£  
> 		//±ÈÈç£¬ÄãÏëÒª´ÓÒ»¸ö·ş´ÓÕıÌ¬·Ö²¼µÄËæ»ú±äÁ¿µÃµ½ 100 ¸öÑù±¾£¬ÄÇÃ´¿Ï¶¨³éµ½½Ó½üÆä¾ùÖµµÄÑù±¾µÄ  
> 		//¸ÅÂÊÒª´óĞí¶à£¬´Ó¶øµ¼ÖÂ³éµ½µÄÑù±¾ºÜ¶àÊÇ¼¯ÖĞÔÚÄÇ¸½½üµÄ¡£  
> 		//rng.uniform()·µ»ØÒ»¸ö´Ó[ 1£¬2£©·¶Î§¾ùÔÈ²ÉÑùµÄËæ»úÊı£¬¼´ÔÚ[ 1£¬2£©ÄÚ·ş´Ó¾ùÔÈ·Ö²¼£¨È¡²»Í¬Öµ¸ÅÂÊÏàÍ¬£©  
> 		//ÄÇÃ´ÏÂÃæµÄ¹¦ÄÜ¾ÍÊÇµÃµ½[2£¬4£©·¶Î§µÄËæ»úÊı£¬È»ºóÓÃcvFloor·µ»Ø²»´óÓÚ²ÎÊıµÄ×î´óÕûÊıÖµ£¬ÄÇÒªÃ´ÊÇ2£¬ÒªÃ´ÊÇ3¡£ 
73c73
< 
---
> 	
76,79c76,79
< 			//ÎÒÔÚÒ»¸öboxÖĞËæ»úÉú³ÉÒ»¸ö¾ØĞÎ¿ò£¬ÄÇºÍÄãÕâ¸öboxµÄxºÍy×ø±ê¾ÍÎŞ¹ØÁË£¬µ«ÎÒ±ØĞë±£Ö¤ÎÒÑ¡Ôñ
< 			//µÄÕâ¸ö¾ØĞÎ¿ò²»»á³¬³öÄãÕâ¸öboxµÄ·¶Î§°¡£¬ÊÇ°É
< 			//µ«ÕâÀïµÄ3ºÍÏÂÃæµÄ2ÊÇÉ¶ÒâË¼ÄØ£¿ÎÒ¾Í²»¶®ÁË£¬¸öÈËÀí½âÊÇÎªÁË±ÜÃâÕâ¸ö¾ØĞÎ¿òÌ«¿¿½üboxµÄ±ßÔµÁË
< 			//ÒªÀë±ßÔµ×îĞ¡2¸öÏñËØ£¬²»ÖªµÀÕâÑùÀí½â¶Ô²»¶Ô£¬¿ÒÇëÖ¸µ¼
---
> 			//ÎÒÔÚÒ»¸öboxÖĞËæ»úÉú³ÉÒ»¸ö¾ØĞÎ¿ò£¬ÄÇºÍÄãÕâ¸öboxµÄxºÍy×ø±ê¾ÍÎŞ¹ØÁË£¬µ«ÎÒ±ØĞë±£Ö¤ÎÒÑ¡Ôñ  
> 			//µÄÕâ¸ö¾ØĞÎ¿ò²»»á³¬³öÄãÕâ¸öboxµÄ·¶Î§°¡£¬ÊÇ°É  
> 			//µ«ÕâÀïµÄ3ºÍÏÂÃæµÄ2ÊÇÉ¶ÒâË¼ÄØ£¿ÎÒ¾Í²»¶®ÁË£¬¸öÈËÀí½âÊÇÎªÁË±ÜÃâÕâ¸ö¾ØĞÎ¿òÌ«¿¿½üboxµÄ±ßÔµÁË  
> 			//ÒªÀë±ßÔµ×îĞ¡2¸öÏñËØ£¬²»ÖªµÀÕâÑùÀí½â¶Ô²»¶Ô£¬¿ÒÇëÖ¸µ¼  
82c82
< 			//cvCeil ·µ»Ø²»Ğ¡ÓÚ²ÎÊıµÄ×îĞ¡ÕûÊıÖµ
---
> 			//cvCeil ·µ»Ø²»Ğ¡ÓÚ²ÎÊıµÄ×îĞ¡ÕûÊıÖµ  
85c85
< 			 //±£´æµÃµ½µÄÌØÕ÷Ä£°å¡£×¢ÒâÅ¶£¬ÕâÀïµÄ¾ØĞÎ¿òÊÇÏà¶ÔÓÚboxµÄÏà¶ÔÎ»ÖÃÅ¶£¬²»ÊÇÕë¶ÔÕû·ùÍ¼ÏñµÄÅ¶
---
> 			 //±£´æµÃµ½µÄÌØÕ÷Ä£°å¡£×¢ÒâÅ¶£¬ÕâÀïµÄ¾ØĞÎ¿òÊÇÏà¶ÔÓÚboxµÄÏà¶ÔÎ»ÖÃÅ¶£¬²»ÊÇÕë¶ÔÕû·ùÍ¼ÏñµÄÅ¶ 
87,93c87,93
< 			//weightTemp = (float)pow(-1.0, c);
< 			//pow(-1.0, c)Ò²¾ÍÊÇ-1µÄc´Î·½£¬¶øcËæ»úµØÈ¡0»òÕß1£¬Ò²¾ÍÊÇËµweightTempÊÇËæ»úµÄÕı»òÕß¸º¡£
< 			//Ëæ»ú²âÁ¿¾ØÕóÖĞ£¬¾ØÕóÔªËØÓĞÈıÖÖ£¬sqrt(s)¡¢-sqrt(s)ºÍÁã¡£ÎªÕıºÍÎª¸ºµÄ¸ÅÂÊÊÇÏàµÈµÄ£¬
< 			//Õâ¾ÍÊÇÎªÊ²Ã´ÊÇ[2£¬4£©¾ùÔÈ²ÉÑùµÄÔ­Òò£¬¾ÍÊÇÈ¡0»òÕß1¸ÅÂÊÒ»Ñù¡£
< 			//µ«ÊÇÕâÀïÎªÊ²Ã´ÊÇsqrt(s)·ÖÖ®Ò»ÄØ£¿»¹ÓĞÊ²Ã´Ê±ºòÊÇ0ÄØ£¿ÂÛÎÄÖĞÊÇ0µÄ¸ÅÂÊ²»ÊÇÍ¦´óµÄÂğ£¿
< 			//Ã»ÓĞ0ÔªËØ£¬ÄÄÀ´µÄÏ¡Êè±í´ïºÍÑ¹ËõÄØ£¿²»¶®£¬¿ÒÇëÖ¸µ¼£¡£¨µ±È»Ï¡Êè±í´ïµÄÁíÒ»¸öºÃ´¦
< 			//¾ÍÊÇÖ»Ğè±£´æ·ÇÁãÔªËØ¡£µ«ÕâÀïºÍÕâ¸öÓĞ¹ØÏµÂğ£¿£©
---
> 			//weightTemp = (float)pow(-1.0, c);  
> 			//pow(-1.0, c)Ò²¾ÍÊÇ-1µÄc´Î·½£¬¶øcËæ»úµØÈ¡0»òÕß1£¬Ò²¾ÍÊÇËµweightTempÊÇËæ»úµÄÕı»òÕß¸º¡£  
> 			//Ëæ»ú²âÁ¿¾ØÕóÖĞ£¬¾ØÕóÔªËØÓĞÈıÖÖ£¬sqrt(s)¡¢-sqrt(s)ºÍÁã¡£ÎªÕıºÍÎª¸ºµÄ¸ÅÂÊÊÇÏàµÈµÄ£¬  
> 			//Õâ¾ÍÊÇÎªÊ²Ã´ÊÇ[2£¬4£©¾ùÔÈ²ÉÑùµÄÔ­Òò£¬¾ÍÊÇÈ¡0»òÕß1¸ÅÂÊÒ»Ñù¡£  
> 			//µ«ÊÇÕâÀïÎªÊ²Ã´ÊÇsqrt(s)·ÖÖ®Ò»ÄØ£¿»¹ÓĞÊ²Ã´Ê±ºòÊÇ0ÄØ£¿ÂÛÎÄÖĞÊÇ0µÄ¸ÅÂÊ²»ÊÇÍ¦´óµÄÂğ£¿  
> 			//Ã»ÓĞ0ÔªËØ£¬ÄÄÀ´µÄÏ¡Êè±í´ïºÍÑ¹ËõÄØ£¿²»¶®£¬¿ÒÇëÖ¸µ¼£¡£¨µ±È»Ï¡Êè±í´ïµÄÁíÒ»¸öºÃ´¦  
> 			//¾ÍÊÇÖ»Ğè±£´æ·ÇÁãÔªËØ¡£µ«ÕâÀïºÍÕâ¸öÓĞ¹ØÏµÂğ£¿£©  
97c97
< 
---
>            
112c112
<    -_objectBox:    recent object position
---
>    -_objectBox:    recent object position 
121,125c121,125
< 	//ÎÒÃÇÊÇÔÚÉÏÒ»Ö¡¸ú×ÙµÄÄ¿±êboxµÄÖÜÎ§²É¼¯ÕıÑù±¾ºÍ¸ºÑù±¾µÄ£¬¶øÕâ¸öÖÜÎ§ÊÇÍ¨¹ıÒÔ
< 	//Õâ¸öÄ¿±êÎªÖĞĞÄµÄÁ½¸öÔ²À´±íÊ¾£¬ÕâÁ½¸öÔ²µÄ°ë¾¶ÊÇ_rInnerºÍ_rOuter¡£
< 	//ÎÒÃÇÔÚÀëÉÏÒ»Ö¡¸ú×ÙµÄÄ¿±êboxµÄĞ¡ÓÚ_rInner¾àÀëµÄ·¶Î§ÄÚ²É¼¯ÕıÑù±¾£¬
< 	//ÔÚ´óÓÚ_rOuter¾àÀëµÄ·¶Î§ÄÚ²É¼¯¸ºÑù±¾£¨ÂÛÎÄÖĞ»¹ÓĞÒ»¸öÉÏ½ç£¬µ«ºÃÏñ
< 	//ÕâÀïÃ»ÓĞ£¬ÆäÊµºÃÏñÒ²Ã»Ê²Ã´±ØÒªàŞ£©
---
> 	//ÎÒÃÇÊÇÔÚÉÏÒ»Ö¡¸ú×ÙµÄÄ¿±êboxµÄÖÜÎ§²É¼¯ÕıÑù±¾ºÍ¸ºÑù±¾µÄ£¬¶øÕâ¸öÖÜÎ§ÊÇÍ¨¹ıÒÔ  
> 	//Õâ¸öÄ¿±êÎªÖĞĞÄµÄÁ½¸öÔ²À´±íÊ¾£¬ÕâÁ½¸öÔ²µÄ°ë¾¶ÊÇ_rInnerºÍ_rOuter¡£  
> 	//ÎÒÃÇÔÚÀëÉÏÒ»Ö¡¸ú×ÙµÄÄ¿±êboxµÄĞ¡ÓÚ_rInner¾àÀëµÄ·¶Î§ÄÚ²É¼¯ÕıÑù±¾£¬  
> 	//ÔÚ´óÓÚ_rOuter¾àÀëµÄ·¶Î§ÄÚ²É¼¯¸ºÑù±¾£¨ÂÛÎÄÖĞ»¹ÓĞÒ»¸öÉÏ½ç£¬µ«ºÃÏñ  
> 	//ÕâÀïÃ»ÓĞ£¬ÆäÊµºÃÏñÒ²Ã»Ê²Ã´±ØÒªàŞ£©  
128c128
< 
---
> 	
130c130
< 	//ÕâËÄ¸öÊÇÎªÁË·ÀÖ¹²É¼¯µÄ¿ò³¬³öÍ¼Ïñ·¶Î§µÄ£¬¶Ô²É¼¯µÄboxµÄxºÍy×ø±ê×öÏŞÖÆ
---
> 	//ÕâËÄ¸öÊÇÎªÁË·ÀÖ¹²É¼¯µÄ¿ò³¬³öÍ¼Ïñ·¶Î§µÄ£¬¶Ô²É¼¯µÄboxµÄxºÍy×ø±ê×öÏŞÖÆ 
135c135
< 
---
> 	
137,139c137,139
< 	//·ÖÄ¸Ïàµ±ÓÚxÄÜ²É¼¯µÄ·¶Î§³ËÒÔyÄÜ²É¼¯µÄ·¶Î§£¬Ò²¾ÍÊÇ¿ÉÒÔ²É¼¯µÄ×î´óbox¸öÊı£¬
< 	//ÄÇÃ´_maxSampleNum£¨ÎÒÃÇĞèÒª²É¼¯µÄboxµÄ×î´ó¸öÊı£©¿Ï¶¨µÃĞ¡ÓÚ»òÕßµÈÓÚËü¡£
< 	//ÄÇÕâ¸öprobÊÇ¸ÉÂïµÄÄØ£¿µ½ÏÂÃæÓÃµ½ËüµÄµØ·½Ëµ
---
> 	//·ÖÄ¸Ïàµ±ÓÚxÄÜ²É¼¯µÄ·¶Î§³ËÒÔyÄÜ²É¼¯µÄ·¶Î§£¬Ò²¾ÍÊÇ¿ÉÒÔ²É¼¯µÄ×î´óbox¸öÊı£¬  
> 	//ÄÇÃ´_maxSampleNum£¨ÎÒÃÇĞèÒª²É¼¯µÄboxµÄ×î´ó¸öÊı£©¿Ï¶¨µÃĞ¡ÓÚ»òÕßµÈÓÚËü¡£  
> 	//ÄÇÕâ¸öprobÊÇ¸ÉÂïµÄÄØ£¿µ½ÏÂÃæÓÃµ½ËüµÄµØ·½Ëµ  
144c144
< 
---
>     
152,157c152,157
< 			//ºóÁ½¸öÌõ¼şÊÇ±£Ö¤¾àÀëĞèÒªÔÚ_rInnerºÍ_rOuterµÄ·¶Î§ÄÚ
< 			//ÄÇÃ´rng.uniform(0.,1.) < prob Õâ¸öÊÇ¸ÉÂïµÄÄØ£¿
< 			//Á¬×ÅÉÏÃæ¿´£¬Èç¹û_maxSampleNum´óÓÚÄÇ¸ö×î´ó¸öÊı£¬prob¾Í´óÓÚ1£¬ÕâÑù£¬
< 			//rng.uniform(0.,1.) < probÕâ¸öÌõ¼ş¾Í×ÜÄÜÂú×ã£¬±íÊ¾ÔÚÕâ¸ö·¶Î§²úÉúµÄ
< 			//ËùÒÔboxÎÒ¶¼ÒªÁË£¨ÒòÎªÎÒ±¾ÉíÏëÒª¸ü¶àµÄ£¬µ«ÊÇÄã¸ø²»ÁËÎÒÄÇÃ´¶à£¬ÄÇÃ´ÄãÄÜ¸øµÄ£¬ÎÒ¿Ï¶¨È«ÒªÁË£©¡£
< 			//ÄÇÈç¹ûÄã¸øµÄÌ«¶àÁË£¬ÎÒ²»ÒªÄÇÃ´¶à£¬Ò²¾ÍÊÇprob<1£¬ÄÇÎÒ¾ÍËæ»úµØÌô¼¸¸ö×ßºÃÁË
---
> 			//ºóÁ½¸öÌõ¼şÊÇ±£Ö¤¾àÀëĞèÒªÔÚ_rInnerºÍ_rOuterµÄ·¶Î§ÄÚ  
> 			//ÄÇÃ´rng.uniform(0.,1.) < prob Õâ¸öÊÇ¸ÉÂïµÄÄØ£¿  
> 			//Á¬×ÅÉÏÃæ¿´£¬Èç¹û_maxSampleNum´óÓÚÄÇ¸ö×î´ó¸öÊı£¬prob¾Í´óÓÚ1£¬ÕâÑù£¬  
> 			//rng.uniform(0.,1.) < probÕâ¸öÌõ¼ş¾Í×ÜÄÜÂú×ã£¬±íÊ¾ÔÚÕâ¸ö·¶Î§²úÉúµÄ  
> 			//ËùÒÔboxÎÒ¶¼ÒªÁË£¨ÒòÎªÎÒ±¾ÉíÏëÒª¸ü¶àµÄ£¬µ«ÊÇÄã¸ø²»ÁËÎÒÄÇÃ´¶à£¬ÄÇÃ´ÄãÄÜ¸øµÄ£¬ÎÒ¿Ï¶¨È«ÒªÁË£©¡£  
> 			//ÄÇÈç¹ûÄã¸øµÄÌ«¶àÁË£¬ÎÒ²»ÒªÄÇÃ´¶à£¬Ò²¾ÍÊÇprob<1£¬ÄÇÎÒ¾ÍËæ»úµØÌô¼¸¸ö×ßºÃÁË  
164,166c164,166
< 
<                 _sampleBox.push_back(rec);
< 
---
> 				
>                 _sampleBox.push_back(rec);				
> 				
170c170
< 
---
> 	
172c172
< 
---
> 		
175,177c175,177
< //Õâ¸ösampleRectµÄÖØÔØº¯ÊıÊÇÓÃÀ´ÔÚÉÏÒ»Ö¡¸ú×ÙµÄÄ¿±êboxµÄÖÜÎ§£¨¾àÀëĞ¡ÓÚ_srw£©²É¼¯Èô¸ÉboxÀ´´ı¼ì²â¡£
< //ÓëÉÏÃæµÄÄÇ¸ö²»Ò»Ñù£¬ÉÏÃæÄÇ¸öÊÇÔÚÕâÒ»Ö¡ÒÑ¾­¼ì²â³öÄ¿±êµÄ»ù´¡ÉÏ£¬²É¼¯Õı¸ºÑù±¾À´¸üĞÂ·ÖÀàÆ÷µÄ¡£
< //ÉÏÃæÄÇ¸öÊôÓÚÂÛÎÄÖĞÌáµ½µÄËã·¨µÄµÚËÄ¸ö²½Öè£¬Õâ¸öÊÇµÚÒ»¸ö²½Öè¡£È»ºó¹ı³Ì²î²»¶à£¬Ã»Ê²Ã´ºÃËµµÄÁË
---
> //Õâ¸ösampleRectµÄÖØÔØº¯ÊıÊÇÓÃÀ´ÔÚÉÏÒ»Ö¡¸ú×ÙµÄÄ¿±êboxµÄÖÜÎ§£¨¾àÀëĞ¡ÓÚ_srw£©²É¼¯Èô¸ÉboxÀ´´ı¼ì²â¡£  
> //ÓëÉÏÃæµÄÄÇ¸ö²»Ò»Ñù£¬ÉÏÃæÄÇ¸öÊÇÔÚÕâÒ»Ö¡ÒÑ¾­¼ì²â³öÄ¿±êµÄ»ù´¡ÉÏ£¬²É¼¯Õı¸ºÑù±¾À´¸üĞÂ·ÖÀàÆ÷µÄ¡£  
> //ÉÏÃæÄÇ¸öÊôÓÚÂÛÎÄÖĞÌáµ½µÄËã·¨µÄµÚËÄ¸ö²½Öè£¬Õâ¸öÊÇµÚÒ»¸ö²½Öè¡£È»ºó¹ı³Ì²î²»¶à£¬Ã»Ê²Ã´ºÃËµµÄÁË  
183,184c183,184
< 	float inradsq = _srw*_srw;
< 
---
> 	float inradsq = _srw*_srw;	
> 	
211c211
< 				_sampleBox.push_back(rec);
---
> 				_sampleBox.push_back(rec);				
215c215
< 
---
> 	
220,224c220,224
< //Í¨¹ı»ı·ÖÍ¼À´¼ÆËã²É¼¯µ½µÄÃ¿Ò»¸öÑù±¾µÄharrÌØÕ÷£¬Õâ¸öÌØÕ÷Í¨¹ıÓëfeaturesWeightÀ´Ïà³Ë
< //¾ÍÏàµ±ÓÚÍ¶Ó°µ½Ëæ»ú²âÁ¿¾ØÕóÖĞÁË£¬Ò²¾ÍÊÇ½øĞĞÏ¡Êè±í´ïÁË¡£ÕâÀï²»Ã÷°×µÄ»°£¬¿ÉÒÔ¿´ÏÂ
< //ÂÛÎÄÖĞµÄÍ¼¶ş£¬¾Í±È½ÏÖ±¹ÛÁË¡£ËùÒÔÕâÀïµÃµ½µÄÊÇ£ºÃ¿¸öÑù±¾µÄÏ¡Êè±í´ïºóµÄharrÌØÕ÷¡£
< //»¹ÓĞÒ»µã£ºÊµ¼ÊÉÏÕâÀï²ÉÓÃµÄ²»ÊôÓÚÕæÕıµÄharrÌØÕ÷£¬ÎÒ²©¿ÍÖĞ·­ÒëÓĞÎó¡£ÕâÀï¼ÆËãµÄÊÇ
< //ÔÚboxÖĞ²ÉÑùµÃµ½µÄ²»Í¬¾ØĞÎ¿òµÄ»Ò¶È¼ÓÈ¨ÇóºÍ
---
> //Í¨¹ı»ı·ÖÍ¼À´¼ÆËã²É¼¯µ½µÄÃ¿Ò»¸öÑù±¾µÄharrÌØÕ÷£¬Õâ¸öÌØÕ÷Í¨¹ıÓëfeaturesWeightÀ´Ïà³Ë  
> //¾ÍÏàµ±ÓÚÍ¶Ó°µ½Ëæ»ú²âÁ¿¾ØÕóÖĞÁË£¬Ò²¾ÍÊÇ½øĞĞÏ¡Êè±í´ïÁË¡£ÕâÀï²»Ã÷°×µÄ»°£¬¿ÉÒÔ¿´ÏÂ  
> //ÂÛÎÄÖĞµÄÍ¼¶ş£¬¾Í±È½ÏÖ±¹ÛÁË¡£ËùÒÔÕâÀïµÃµ½µÄÊÇ£ºÃ¿¸öÑù±¾µÄÏ¡Êè±í´ïºóµÄharrÌØÕ÷¡£  
> //»¹ÓĞÒ»µã£ºÊµ¼ÊÉÏÕâÀï²ÉÓÃµÄ²»ÊôÓÚÕæÕıµÄharrÌØÕ÷£¬ÎÒ²©¿ÍÖĞ·­ÒëÓĞÎó¡£ÕâÀï¼ÆËãµÄÊÇ  
> //ÔÚboxÖĞ²ÉÑùµÃµ½µÄ²»Í¬¾ØĞÎ¿òµÄ»Ò¶È¼ÓÈ¨ÇóºÍ  
242,243c242,243
< 				//featuresÖĞ±£´æµÄÌØÕ÷Ä£°å£¨¾ØĞÎ¿ò£©ÊÇÏà¶ÔÓÚboxµÄÏà¶ÔÎ»ÖÃµÄ£¬
< 				//ËùÒÔĞèÒª¼ÓÉÏboxµÄ×ø±ê²ÅÊÇÆäÔÚÕû·ùÍ¼ÏñÖĞµÄ×ø±ê
---
> 				//featuresÖĞ±£´æµÄÌØÕ÷Ä£°å£¨¾ØĞÎ¿ò£©ÊÇÏà¶ÔÓÚboxµÄÏà¶ÔÎ»ÖÃµÄ£¬  
> 				//ËùÒÔĞèÒª¼ÓÉÏboxµÄ×ø±ê²ÅÊÇÆäÔÚÕû·ùÍ¼ÏñÖĞµÄ×ø±ê  
248,252c248,252
< 				//Í¨¹ı»ı·ÖÍ¼À´¿ìËÙ¼ÆËãÒ»¸ö¾ØĞÎ¿òµÄÏñËØºÍ£¬»ı·ÖÍ¼²»ÁË½âµÄ»°£¬¿ÉÒÔ¿´ÏÂÎÒµÄÕâ¸ö²©ÎÄ£º
< 				//http://blog.csdn.net/zouxy09/article/details/7929570
< 				//ÄÇÃ´ÕâÀïtempValue¾ÍÊÇ¾­¹ıÏ¡ÊÍ¾ØÕó¼ÓÈ¨ºóµÄ»Ò¶ÈºÍÁË¡£
< 				//Ã¿Ò»¸öharrÌØÕ÷ÊÇÓÉ2µ½3¸ö¾ØĞÎ¿òÀ´¹¹³ÉµÄ£¬¶ÔÕâĞ©¾ØĞÎ¿òµÄ»Ò¶È¼ÓÈ¨ÇóºÍ
< 				//×÷ÎªÕâÒ»¸öharrÌØÕ÷µÄÌØÕ÷Öµ¡£È»ºóÒ»¸öÑù±¾ÓĞ50¸öharrÌØÕ÷
---
> 				//Í¨¹ı»ı·ÖÍ¼À´¿ìËÙ¼ÆËãÒ»¸ö¾ØĞÎ¿òµÄÏñËØºÍ£¬»ı·ÖÍ¼²»ÁË½âµÄ»°£¬¿ÉÒÔ¿´ÏÂÎÒµÄÕâ¸ö²©ÎÄ£º  
> 				//http://blog.csdn.net/zouxy09/article/details/7929570  
> 				//ÄÇÃ´ÕâÀïtempValue¾ÍÊÇ¾­¹ıÏ¡ÊÍ¾ØÕó¼ÓÈ¨ºóµÄ»Ò¶ÈºÍÁË¡£  
> 				//Ã¿Ò»¸öharrÌØÕ÷ÊÇÓÉ2µ½3¸ö¾ØĞÎ¿òÀ´¹¹³ÉµÄ£¬¶ÔÕâĞ©¾ØĞÎ¿òµÄ»Ò¶È¼ÓÈ¨ÇóºÍ  
> 				//×÷ÎªÕâÒ»¸öharrÌØÕ÷µÄÌØÕ÷Öµ¡£È»ºóÒ»¸öÑù±¾ÓĞ50¸öharrÌØÕ÷  
258c258
< 				tempValue += featuresWeight[i][k] *
---
> 				tempValue += featuresWeight[i][k] * 
270,271c270,271
< //ÂÛÎÄÖĞÊÇÍ¨¹ıÓÃ¸ßË¹·Ö²¼È¥ÃèÊöÑù±¾µÄÃ¿Ò»¸öharrÌØÕ÷µÄ¸ÅÂÊ·Ö²¼µÄ¡£¸ßË¹·Ö²¼¾Í¿ÉÒÔÍ¨¹ıÆÚÍûºÍ·½²î
< //Á½¸ö²ÎÊıÀ´±íÕ÷¡£È»ºóÍ¨¹ıÕı¸ºÑù±¾µÄÃ¿Ò»¸öharrÌØÕ÷¸ßË¹¸ÅÂÊ·Ö²¼µÄ¶ÔÊı±ÈÖµ£¬À´¹¹½¨·ÖÀàÆ÷¾ö²ß
---
> //ÂÛÎÄÖĞÊÇÍ¨¹ıÓÃ¸ßË¹·Ö²¼È¥ÃèÊöÑù±¾µÄÃ¿Ò»¸öharrÌØÕ÷µÄ¸ÅÂÊ·Ö²¼µÄ¡£¸ßË¹·Ö²¼¾Í¿ÉÒÔÍ¨¹ıÆÚÍûºÍ·½²î  
> //Á½¸ö²ÎÊıÀ´±íÕ÷¡£È»ºóÍ¨¹ıÕı¸ºÑù±¾µÄÃ¿Ò»¸öharrÌØÕ÷¸ßË¹¸ÅÂÊ·Ö²¼µÄ¶ÔÊı±ÈÖµ£¬À´¹¹½¨·ÖÀàÆ÷¾ö²ß  
277c277
< //_mu:_mu.size()Îª50£» _sigma:_sigma.size()Îª50£»
---
> //_mu:_mu.size()Îª50£» _sigma:_sigma.size()Îª50£» 
283c283
< 
---
>     
289c289
< 		_sigma[i] = (float)sqrt( _learnRate*_sigma[i]*_sigma[i]	+ (1.0f-_learnRate)*sigmaTemp.val[0]*sigmaTemp.val[0]
---
> 		_sigma[i] = (float)sqrt( _learnRate*_sigma[i]*_sigma[i]	+ (1.0f-_learnRate)*sigmaTemp.val[0]*sigmaTemp.val[0] 
296c296
< // Compute the ratio classifier
---
> // Compute the ratio classifier 
301c301
< 	//FLT_MAXÊÇ×î´óµÄ¸¡µãÊıµÄºê¶¨Òå£¬ÄÇÃ´-FLT_MAX¾ÍÊÇ×îĞ¡µÄ¸¡µãÊıÁË
---
> 	//FLT_MAXÊÇ×î´óµÄ¸¡µãÊıµÄºê¶¨Òå£¬ÄÇÃ´-FLT_MAX¾ÍÊÇ×îĞ¡µÄ¸¡µãÊıÁË  
304c304
< 	//Õâ¸öÊÇ¶ÔÓ¦ÓÚÉÏÃæÄÇ¸ö£¬ÊÇ´æ·Å·ÖÀà·ÖÊı×î´óµÄÄÇ¸öboxµÄ
---
> 	//Õâ¸öÊÇ¶ÔÓ¦ÓÚÉÏÃæÄÇ¸ö£¬ÊÇ´æ·Å·ÖÀà·ÖÊı×î´óµÄÄÇ¸öboxµÄ  
313c313
< 		for (int i=0; i<featureNum; i++)//Ã¿¸öboxµÄĞèÒªÆ¥ÅäµÄÌØÕ÷Êı
---
> 		for (int i=0; i<featureNum; i++)//Ã¿¸öboxµÄĞèÒªÆ¥ÅäµÄÌØÕ÷Êı  
315,317c315,317
< 			//¼ÆËãÃ¿¸öÌØÕ÷µÄ¸ÅÂÊ£¬ÌØÕ÷·Ö²¼½üËÆÓÚ¸ßË¹·Ö²¼£¬¹Ê½«ÃèÊö¸ÃÌØÕ÷µÄ¾ùÖµºÍ±ê×¼²î´úÈë¸ßË¹Ä£ĞÍ¾Í¿ÉÒÔ
< 			//µÃµ½£¬·Ö±ğÔÚÕıÑù±¾ºÍ¸ºÑù±¾µÄ»ù´¡ÉÏ£¬³öÏÖ¸ÃÌØÕ÷µÄ¸ÅÂÊÊÇ¶àÉÙ¡£Èç¹ûÕıÑù±¾Ê±ºòµÄ¸ÅÂÊ´ó£¬ÄÇÃ´
< 			//ÎÒÃÇ¾ÍËµ£¬Õâ¸öÌØÕ÷¶ÔÓ¦µÄÑù±¾ÊÇÕıÑù±¾¡£ÊıÑ§ÉÏ±È½Ï´óĞ¡£¬¾ÍÊÇ¼õ·¨»òÕß³ı·¨ÁË£¬ÕâÀïÊÇÈ¡¶ÔÊı±ÈÖµ
---
> 			//¼ÆËãÃ¿¸öÌØÕ÷µÄ¸ÅÂÊ£¬ÌØÕ÷·Ö²¼½üËÆÓÚ¸ßË¹·Ö²¼£¬¹Ê½«ÃèÊö¸ÃÌØÕ÷µÄ¾ùÖµºÍ±ê×¼²î´úÈë¸ßË¹Ä£ĞÍ¾Í¿ÉÒÔ  
> 			//µÃµ½£¬·Ö±ğÔÚÕıÑù±¾ºÍ¸ºÑù±¾µÄ»ù´¡ÉÏ£¬³öÏÖ¸ÃÌØÕ÷µÄ¸ÅÂÊÊÇ¶àÉÙ¡£Èç¹ûÕıÑù±¾Ê±ºòµÄ¸ÅÂÊ´ó£¬ÄÇÃ´  
> 			//ÎÒÃÇ¾ÍËµ£¬Õâ¸öÌØÕ÷¶ÔÓ¦µÄÑù±¾ÊÇÕıÑù±¾¡£ÊıÑ§ÉÏ±È½Ï´óĞ¡£¬¾ÍÊÇ¼õ·¨»òÕß³ı·¨ÁË£¬ÕâÀïÊÇÈ¡¶ÔÊı±ÈÖµ  
320,322c320,322
< 			//paperµÄ·½³Ì4£º¼ÆËã·ÖÀà½á¹û£¬µÃµ½Ò»¸ö·ÖÊı£¬Õâ¸ö·ÖÊıÊÇÓÉÒ»¸öÑù±¾»òÕßboxµÄ50¸öÌØÕ÷£¨Èõ·ÖÀà£©
< 			//½øÈë·ÖÀàÆ÷·ÖÀàµÃµ½µÄ½á¹û×ÜºÍ£¨Ç¿·ÖÀà£¿£©¡£±íÕ÷µÄÊÇÄ¿Ç°Õâ¸öboxµÄÌØÕ÷ÊôÓÚÕıÑù±¾£¨Ä¿±ê£©µÄ
< 			//¿ÉÄÜĞÔ´óĞ¡¡£ÄÄ¸ö·ÖÊı×î´ó£¬×ÔÈ»ÎÒ¾ÍÈÏÎªÄãÊÇÄ¿±êÁË¡££¨µ±È»£¬ÔÚ¾ßÌåÓ¦ÓÃÖĞĞèÒª¼ÓÒ»Ğ©²ßÂÔÈ¥
---
> 			//paperµÄ·½³Ì4£º¼ÆËã·ÖÀà½á¹û£¬µÃµ½Ò»¸ö·ÖÊı£¬Õâ¸ö·ÖÊıÊÇÓÉÒ»¸öÑù±¾»òÕßboxµÄ50¸öÌØÕ÷£¨Èõ·ÖÀà£©  
> 			//½øÈë·ÖÀàÆ÷·ÖÀàµÃµ½µÄ½á¹û×ÜºÍ£¨Ç¿·ÖÀà£¿£©¡£±íÕ÷µÄÊÇÄ¿Ç°Õâ¸öboxµÄÌØÕ÷ÊôÓÚÕıÑù±¾£¨Ä¿±ê£©µÄ  
> 			//¿ÉÄÜĞÔ´óĞ¡¡£ÄÄ¸ö·ÖÊı×î´ó£¬×ÔÈ»ÎÒ¾ÍÈÏÎªÄãÊÇÄ¿±êÁË¡££¨µ±È»£¬ÔÚ¾ßÌåÓ¦ÓÃÖĞĞèÒª¼ÓÒ»Ğ©²ßÂÔÈ¥  
326c326
< 		if (_radioMax < sumRadio)//ÄÃµ½×î´óµÄ·ÖÊıºÍÏàÓ¦µÄboxË÷Òı
---
> 		if (_radioMax < sumRadio)//ÄÃµ½×î´óµÄ·ÖÊıºÍÏàÓ¦µÄboxË÷Òı  
338c338
< 	//¼ÆËãboxµÄharrÌØÕ÷Ä£°å£¬ÏÈ´æ×Å
---
> 	//¼ÆËãboxµÄharrÌØÕ÷Ä£°å£¬ÏÈ´æ×Å  
342,343c342,343
< 	//ÒòÎªÕâÊÇµÚÒ»Ö¡£¬Ä¿±êboxÊÇÓÉÓÉÎÄ¼ş¶ÁÈë»òÕßÓÃ»§Êó±ê¿òÑ¡µÄ£¬ÊÇÒÑÖªµÄ£¬
< 	//ËùÒÔÎÒÃÇÍ¨¹ıÔÚÕâ¸öÄ¿±êboxÖÜÎ§£¬²É¼¯ÕıÑù±¾ºÍ¸ºÑù±¾À´³õÊ¼»¯ÎÒÃÇµÄ·ÖÀàÆ÷
---
> 	//ÒòÎªÕâÊÇµÚÒ»Ö¡£¬Ä¿±êboxÊÇÓÉÓÉÎÄ¼ş¶ÁÈë»òÕßÓÃ»§Êó±ê¿òÑ¡µÄ£¬ÊÇÒÑÖªµÄ£¬  
> 	//ËùÒÔÎÒÃÇÍ¨¹ıÔÚÕâ¸öÄ¿±êboxÖÜÎ§£¬²É¼¯ÕıÑù±¾ºÍ¸ºÑù±¾À´³õÊ¼»¯ÎÒÃÇµÄ·ÖÀàÆ÷ 
357c357
< 	//Í¨¹ıÉÏÃæµÄ»ı·ÖÍ¼£¬¼ÆËãÎÒÃÇ²ÉÑùµ½µÄÕı¸ºÑù±¾µÄboxµÄharrÌØÕ÷
---
> 	//Í¨¹ıÉÏÃæµÄ»ı·ÖÍ¼£¬¼ÆËãÎÒÃÇ²ÉÑùµ½µÄÕı¸ºÑù±¾µÄboxµÄharrÌØÕ÷  
365c365
< //´«ÈëÉÏÒ»Ö¡¸ú×Ùµ½µÄbox£¬À´´¦ÀíĞÂµÄÒ»Ö¡
---
> //´«ÈëÉÏÒ»Ö¡¸ú×Ùµ½µÄbox£¬À´´¦ÀíĞÂµÄÒ»Ö¡  
378c378
< 	//¶ÔÉÏÃæµÄÃ¿¸öbox½øĞĞÆ¥Åä·ÖÀà
---
> 	//¶ÔÉÏÃæµÄÃ¿¸öbox½øĞĞÆ¥Åä·ÖÀà  
385c385
< 	//ÔÚĞÂ¸ú×Ùµ½µÄÕâ¸öÄ¿±êboxµÄÖÜÎ§£¬²É¼¯ÕıÑù±¾ºÍ¸ºÑù±¾À´¸üĞÂÎÒÃÇµÄ·ÖÀàÆ÷
---
> 	//ÔÚĞÂ¸ú×Ùµ½µÄÕâ¸öÄ¿±êboxµÄÖÜÎ§£¬²É¼¯ÕıÑù±¾ºÍ¸ºÑù±¾À´¸üĞÂÎÒÃÇµÄ·ÖÀàÆ÷  
388c388
< 	//Í¨¹ıÉÏÃæµÄ»ı·ÖÍ¼£¬¼ÆËãÎÒÃÇ²ÉÑùµ½µÄÕı¸ºÑù±¾µÄboxµÄharrÌØÕ÷
---
> 	//Í¨¹ıÉÏÃæµÄ»ı·ÖÍ¼£¬¼ÆËãÎÒÃÇ²ÉÑùµ½µÄÕı¸ºÑù±¾µÄboxµÄharrÌØÕ÷  
391c391
< 	//Í¨¹ıÉÏÃæµÄÕı¸ºÑù±¾µÄÌØÕ÷À´¸üĞÂÎÒÃÇµÄ·ÖÀàÆ÷
---
> 	//Í¨¹ıÉÏÃæµÄÕı¸ºÑù±¾µÄÌØÕ÷À´¸üĞÂÎÒÃÇµÄ·ÖÀàÆ÷  
395c395
< }
---
> }
\ æ–‡ä»¶å°¾æ²¡æœ‰ newline å­—ç¬¦
diff libdetect_t_bak/ct.h libdetect_t_bak2/ct.h
18c18
< #include <opencv2/opencv1.hpp>
---
> #include <opencv2/opencv.hpp>
34,35c34,35
< 	vector<vector<cv::Rect> > features;//Ã¿¸öboxµÄharrÌØÕ÷¸öÊı£¨Ò²¾ÍÊÇÈõ·ÖÀàÆ÷¸öÊı£©
< 	vector<vector<float> > featuresWeight;
---
> 	vector<vector<cv::Rect>> features;//Ã¿¸öboxµÄharrÌØÕ÷¸öÊı£¨Ò²¾ÍÊÇÈõ·ÖÀàÆ÷¸öÊı£©  
> 	vector<vector<float>> featuresWeight;
37,38c37,38
< 	vector<cv::Rect> samplePositiveBox;//²É¼¯µÄÕıÑù±¾box¼¯
< 	vector<cv::Rect> sampleNegativeBox;//²É¼¯µÄ¸ºÑù±¾box¼¯
---
> 	vector<cv::Rect> samplePositiveBox;//²É¼¯µÄÕıÑù±¾box¼¯ 
> 	vector<cv::Rect> sampleNegativeBox;//²É¼¯µÄ¸ºÑù±¾box¼¯ 
43,45c43,45
< 	//¶ÔÃ¿¸öÑù±¾z£¨mÎ¬ÏòÁ¿£©£¬ËüµÄµÍÎ¬±íÊ¾ÊÇv£¨nÎ¬ÏòÁ¿£¬nÔ¶Ğ¡ÓÚm£©¡£¼Ù¶¨vÖĞµÄ¸÷ÔªËØÊÇ¶ÀÁ¢·Ö²¼µÄ¡£
< 	//¼Ù¶¨ÔÚ·ÖÀàÆ÷H(v)ÖĞµÄÌõ¼ş¸ÅÂÊp(vi|y=1)ºÍp(vi|y=0)ÊôÓÚ¸ßË¹·Ö²¼£¬²¢ÇÒ¿ÉÒÔÓÃÒÔÏÂËÄ¸ö²ÎÊıÀ´ÃèÊö£º
< 	//·Ö±ğÊÇÃèÊöÕı¸ºÑù±¾µÄ¸ßË¹·Ö²¼µÄ¾ùÖµuºÍ·½²îsigma
---
> 	//¶ÔÃ¿¸öÑù±¾z£¨mÎ¬ÏòÁ¿£©£¬ËüµÄµÍÎ¬±íÊ¾ÊÇv£¨nÎ¬ÏòÁ¿£¬nÔ¶Ğ¡ÓÚm£©¡£¼Ù¶¨vÖĞµÄ¸÷ÔªËØÊÇ¶ÀÁ¢·Ö²¼µÄ¡£  
> 	//¼Ù¶¨ÔÚ·ÖÀàÆ÷H(v)ÖĞµÄÌõ¼ş¸ÅÂÊp(vi|y=1)ºÍp(vi|y=0)ÊôÓÚ¸ßË¹·Ö²¼£¬²¢ÇÒ¿ÉÒÔÓÃÒÔÏÂËÄ¸ö²ÎÊıÀ´ÃèÊö£º  
> 	//·Ö±ğÊÇÃèÊöÕı¸ºÑù±¾µÄ¸ßË¹·Ö²¼µÄ¾ùÖµuºÍ·½²îsigma  
50c50
< 	float learnRate;//Ñ§Ï°ËÙÂÊ£¬¿ØÖÆ·ÖÀàÆ÷²ÎÊı¸üĞÂµÄ²½³¤
---
> 	float learnRate;//Ñ§Ï°ËÙÂÊ£¬¿ØÖÆ·ÖÀàÆ÷²ÎÊı¸üĞÂµÄ²½³¤ 
53c53
< 	RNG rng;//Ëæ»úÊı
---
> 	RNG rng;//Ëæ»úÊı 
65c65
< 	cv::Rect processFrame(Mat& _frame, cv::Rect objectBox);
---
> 	cv::Rect CompressiveTracker::processFrame(Mat& _frame, cv::Rect objectBox);
åªåœ¨ libdetect_t_bak å­˜åœ¨ï¼šct.o
diff libdetect_t_bak/detect_t.cpp libdetect_t_bak2/detect_t.cpp
5c5
<     flag = false;
---
> 	flag = false;
11,15c11,41
<     //bg_model.set("var_Threshold",80);
<     //bg_model.set("fTau",0.2);//é˜´å½±æ¶ˆé™¤å‚æ•°ï¼Œ0-1ä¹‹é—´ï¼Œé»˜è®¤ä¸º0.5ï¼Œè¶Šå°ï¼Œé˜´å½±æ¶ˆé™¤è¶Šå‰å®³
<     //mog_learn_rate = atof(cfg_->get_value("t_mog_learn_rate","0.05"));
<     up_update.region_interval = atof(cfg_->get_value("t_upbody_region_interval","40"));
<     up_update.frame_num = 0;
---
> 	//bg_model.set("var_Threshold",80);
> 	//bg_model.set("fTau",0.2);//é˜´å½±æ¶ˆé™¤å‚æ•°ï¼Œ0-1ä¹‹é—´ï¼Œé»˜è®¤ä¸º0.5ï¼Œè¶Šå°ï¼Œé˜´å½±æ¶ˆé™¤è¶Šå‰å®³
> 	//mog_learn_rate = atof(cfg_->get_value("t_mog_learn_rate","0.05"));
> 	up_update.region_interval = atof(cfg_->get_value("t_upbody_region_interval","40"));
> 	up_update.frame_num = 0;
> 
> 	video_width_ = atof(cfg_->get_value("video_width", "480"));
> 	video_height_ = atof(cfg_->get_value("video_height", "270"));
> 
> 	min_area = (video_width_/480.0)*atof(cfg_->get_value("min_area", "150"));
> 	min_rect_area = (video_width_/480.0)*atof(cfg_->get_value("min_rect_area", "300"));
> 	//up_update.min_area = (video_width_/480.0)*atof(cfg_->get_value("t_upbody_min_area", "1000"));
> 	up_update.min_rect_area = (video_width_/480.0)*atof(cfg_->get_value("upbody_min_rect_area", "1000"));
> 
> 	up_update.is_upbody = false;
> 
> 	luv_u_max = atof(cfg_->get_value("luv_u_max", "23"));
> 	luv_v_max = atof(cfg_->get_value("luv_v_max", "23"));
> 	luv_L = atof(cfg_->get_value("luv_L", "50"));
> 
> 	up_update.Y_value = atoi(cfg_->get_value("upbody_L", "40"));
> 	up_update.upbody_u_max = atof(cfg_->get_value("upbody_u_max", "23"));
> 	up_update.upbody_v_max = atof(cfg_->get_value("upbody_v_max", "23"));
> 
> 	init_fillbg_struct(fillbg_struct);
> 
> 	//å›¾åƒæ©ç ;
> 	init_mask();
> 	
> 	//å¸§å·®æ³•;
> 	init_frame_struct(frame_s);
17,18c43,44
<     video_width_ = atof(cfg_->get_value("video_width", "480"));
<     video_height_ = atof(cfg_->get_value("video_height", "270"));
---
> 	//åˆå§‹åŒ–èƒŒæ™¯æ›´æ–°ç®—æ³•;
> 	reset(ud_bg_s);
20,46c46
<     min_area = (video_width_/480.0)*atof(cfg_->get_value("min_area", "150"));
<     min_rect_area = (video_width_/480.0)*atof(cfg_->get_value("min_rect_area", "300"));
<     //up_update.min_area = (video_width_/480.0)*atof(cfg_->get_value("t_upbody_min_area", "1000"));
<     up_update.min_rect_area = (video_width_/480.0)*atof(cfg_->get_value("upbody_min_rect_area", "1000"));
< 
<     up_update.is_upbody = false;
< 
<     luv_u_max = atof(cfg_->get_value("luv_u_max", "23"));
<     luv_v_max = atof(cfg_->get_value("luv_v_max", "23"));
<     luv_L = atof(cfg_->get_value("luv_L", "50"));
< 
<     up_update.Y_value = atoi(cfg_->get_value("upbody_L", "40"));
<     up_update.upbody_u_max = atof(cfg_->get_value("upbody_u_max", "23"));
<     up_update.upbody_v_max = atof(cfg_->get_value("upbody_v_max", "23"));
< 
<     init_fillbg_struct(fillbg_struct);
< 
<     //å›¾åƒæ©ç ;
<     init_mask();
< 
<     //å¸§å·®æ³•;
<     init_frame_struct(frame_s);
< 
<     //åˆå§‹åŒ–èƒŒæ™¯æ›´æ–°ç®—æ³•;
<     reset(ud_bg_s);
< 
<     reset_upbody(up_update.bg_upbody);
---
> 	reset_upbody(up_update.bg_upbody);
57,78c57,78
<     //é™æ­¢ç›®æ ‡åŒºåŸŸæ›´æ–°èƒŒæ™¯æ—¶é—´;
<     fillbg_struct.continued_time =atof(cfg_->get_value("t_continued_time_static", "15"));
<     //å•ç›®æ ‡æ— å¸§å·®èƒŒæ™¯æ›´æ–°æ—¶é—´;
<     fillbg_struct.continued_time_long=atof(cfg_->get_value("t_continued_time_long", "100"));
<     //æ£€æµ‹åˆ°æœ‰ç›®æ ‡èµ°ä¸‹è®²å°åŒºåæ›´æ–°èƒŒæ™¯æ—¶é—´;
<     fillbg_struct.mog2_s.continued_time=atof(cfg_->get_value("t_continued_time_teacherdown", "5"));
<     //æ— ç›®æ ‡èƒŒæ™¯æ›´æ–°æ—¶é—´;
<     //fillbg_struct.norect_update_time=atof(cfg_->get_value("mog2_norect_update_time", "20"));
< 
<     //äººä½“åœ¨å›¾åƒä¸­å¤§æ¦‚å çš„å®½åº¦;
<     fillbg_struct.body_width = (video_width_/480.0)*atof(cfg_->get_value("t_body_width", "40"));
<     fillbg_struct.mog2_interval1 =fillbg_struct.body_width*5;
<     fillbg_struct.mog2_interval2 =fillbg_struct.body_width*3;
<     fillbg_struct.second_interval =(video_width_/480.0)*atof(cfg_->get_value("mog2_second_interval", "10"));
< 
<     fillbg_struct.isfillok = false;
<     fillbg_struct.isfillok_end = false;
<     fillbg_struct.body_move = false;
< 
<     fillbg_struct.nframe = 0;
<     fillbg_struct.num = 0;
<     fillbg_struct.filltwice_num = 0;
---
> 	//é™æ­¢ç›®æ ‡åŒºåŸŸæ›´æ–°èƒŒæ™¯æ—¶é—´;
> 	fillbg_struct.continued_time =atof(cfg_->get_value("t_continued_time_static", "15"));
> 	//å•ç›®æ ‡æ— å¸§å·®èƒŒæ™¯æ›´æ–°æ—¶é—´;
> 	fillbg_struct.continued_time_long=atof(cfg_->get_value("t_continued_time_long", "100"));
> 	//æ£€æµ‹åˆ°æœ‰ç›®æ ‡èµ°ä¸‹è®²å°åŒºåæ›´æ–°èƒŒæ™¯æ—¶é—´;
> 	fillbg_struct.mog2_s.continued_time=atof(cfg_->get_value("t_continued_time_teacherdown", "5"));
> 	//æ— ç›®æ ‡èƒŒæ™¯æ›´æ–°æ—¶é—´;
> 	//fillbg_struct.norect_update_time=atof(cfg_->get_value("mog2_norect_update_time", "20"));
> 
> 	//äººä½“åœ¨å›¾åƒä¸­å¤§æ¦‚å çš„å®½åº¦;
> 	fillbg_struct.body_width = (video_width_/480.0)*atof(cfg_->get_value("t_body_width", "40"));
> 	fillbg_struct.mog2_interval1 =fillbg_struct.body_width*5;
> 	fillbg_struct.mog2_interval2 =fillbg_struct.body_width*3;
> 	fillbg_struct.second_interval =(video_width_/480.0)*atof(cfg_->get_value("mog2_second_interval", "10"));
> 
> 	fillbg_struct.isfillok = false;
> 	fillbg_struct.isfillok_end = false;
> 	fillbg_struct.body_move = false;
> 
> 	fillbg_struct.nframe = 0;
> 	fillbg_struct.num = 0;
> 	fillbg_struct.filltwice_num = 0;
80c80
<     fillbg_struct.mog2_s.flag = false;
---
> 	fillbg_struct.mog2_s.flag = false;
86,93c86,93
<     frame_s.is_body_down = false;
<     frame_s.N = 2;
<     frame_s.threshold_three = atoi(cfg_->get_value("t_frame_threshold_three", "20"));
<     frame_s.threshold_two = atoi(cfg_->get_value("t_frame_threshold_two", "25"));
<     frame_s.interval = fillbg_struct.body_width*3;
<     frame_s.minarea = (video_width_/480.0)*atoi(cfg_->get_value("t_frame_minarea", "10"));
<     frame_s.minrect = (video_width_/480.0)*atoi(cfg_->get_value("t_frame_minrect", "100"));
<     frame_s.bottom_inter = (video_width_/480.0)*atoi(cfg_->get_value("t_frame_bottom_inter_new", "50"));
---
> 	frame_s.is_body_down = false;
> 	frame_s.N = 2;
> 	frame_s.threshold_three = atoi(cfg_->get_value("t_frame_threshold_three", "20"));
> 	frame_s.threshold_two = atoi(cfg_->get_value("t_frame_threshold_two", "25"));
> 	frame_s.interval = fillbg_struct.body_width*3;
> 	frame_s.minarea = (video_width_/480.0)*atoi(cfg_->get_value("t_frame_minarea", "10"));
> 	frame_s.minrect = (video_width_/480.0)*atoi(cfg_->get_value("t_frame_minrect", "100"));
> 	frame_s.bottom_inter = (video_width_/480.0)*atoi(cfg_->get_value("t_frame_bottom_inter_new", "50"));
99,140c99,140
<     ismask_ = false;
<     masked_rect = get_rect(Rect(0, 0, video_width_, video_height_), cfg_->get_value("calibration_data", "0"),cfg_->get_value("calibration_data_2", "0"));
<     const char*cb_date,*cb_date_2;
<     if(cfg_->get_value("calibration_data", "0"))
<         cb_date = "calibration_data";
<     else
<         cb_date = NULL;
<     if(cfg_->get_value("calibration_data_2", "0"))
<         cb_date_2 = "calibration_data_2";
<     else
<         cb_date_2 = NULL;
<     ismask_ = build_mask(img_mask_, masked_rect, cb_date, cb_date_2);
< 
<     is_up_mask_ = false;
<     upbody_masked_rect = get_rect(Rect(0, 0, video_width_, video_height_), cfg_->get_value("upbody_calibration_data", 0));
<     const char *up_cb_date;
<     if(cfg_->get_value("upbody_calibration_data", "0"))
<         up_cb_date = "upbody_calibration_data";
<     else
<         up_cb_date = NULL;
<     is_up_mask_ = build_mask(upbody_img_mask_, upbody_masked_rect, up_cb_date);
< 
<     screen_rect = get_rect(Rect(0, 0, 0, 0), cfg_->get_value("upbody_calibration_data_hollow", 0));
<     screen_rect = Rect(screen_rect.x, 0, screen_rect.width, video_height_); // ä¸Šä¸‹æ‰©å±• ...
<     //-----------------------------
<     //ismask_ = false;
<     //masked_rect = get_rect(cfg_->get_value("calibration_data", "0"),cfg_->get_value("calibration_data_2", "0"));
<     //int expend_height = fillbg_struct.body_width;
<     //cv::Rect upbody_rect = get_rect(cfg_->get_value("upbody_calibration_data", 0),cfg_->get_value("up_calibration_data_2", "0"));
<     //upbody_masked_rect = cv::Rect(upbody_rect.x,upbody_rect.y-3*expend_height,
<     //  upbody_rect.width,(3*expend_height + upbody_rect.height+expend_height));//&&&&&&&&&&&&&&;
<     //upbody_masked_rect &= cv::Rect(0,0,video_width_,video_height_);
<     //const char*cb_date,*cb_date_2;
<     //if(cfg_->get_value("calibration_data", "0"))
<     //  cb_date = "calibration_data";
<     //else
<     //  cb_date = NULL;
<     //if(cfg_->get_value("calibration_data_2", "0"))
<     //  cb_date_2 = "calibration_data_2";
<     //else
<     //  cb_date_2 = NULL;
<     //img_mask_ = build_mask(cb_date,cb_date_2);
---
> 	ismask_ = false;
> 	masked_rect = get_rect(Rect(0, 0, video_width_, video_height_), cfg_->get_value("calibration_data", "0"),cfg_->get_value("calibration_data_2", "0"));
> 	const char*cb_date,*cb_date_2;
> 	if(cfg_->get_value("calibration_data", "0"))
> 		cb_date = "calibration_data";
> 	else
> 		cb_date = NULL;
> 	if(cfg_->get_value("calibration_data_2", "0"))
> 		cb_date_2 = "calibration_data_2";
> 	else
> 		cb_date_2 = NULL;
> 	ismask_ = build_mask(img_mask_, masked_rect, cb_date, cb_date_2);
> 
> 	is_up_mask_ = false;
> 	upbody_masked_rect = get_rect(Rect(0, 0, video_width_, video_height_), cfg_->get_value("upbody_calibration_data", 0));
> 	const char *up_cb_date;
> 	if(cfg_->get_value("upbody_calibration_data", "0"))
> 		up_cb_date = "upbody_calibration_data";
> 	else
> 		up_cb_date = NULL;
> 	is_up_mask_ = build_mask(upbody_img_mask_, upbody_masked_rect, up_cb_date);
> 	
> 	screen_rect = get_rect(Rect(0, 0, 0, 0), cfg_->get_value("upbody_calibration_data_hollow", 0));
> 	screen_rect = Rect(screen_rect.x, 0, screen_rect.width, video_height_); // ä¸Šä¸‹æ‰©å±• ...
> 	//-----------------------------
> 	//ismask_ = false;
> 	//masked_rect = get_rect(cfg_->get_value("calibration_data", "0"),cfg_->get_value("calibration_data_2", "0"));
> 	//int expend_height = fillbg_struct.body_width;
> 	//cv::Rect upbody_rect = get_rect(cfg_->get_value("upbody_calibration_data", 0),cfg_->get_value("up_calibration_data_2", "0"));
> 	//upbody_masked_rect = cv::Rect(upbody_rect.x,upbody_rect.y-3*expend_height,
> 	//	upbody_rect.width,(3*expend_height + upbody_rect.height+expend_height));//&&&&&&&&&&&&&&;
> 	//upbody_masked_rect &= cv::Rect(0,0,video_width_,video_height_);
> 	//const char*cb_date,*cb_date_2;
> 	//if(cfg_->get_value("calibration_data", "0"))
> 	//	cb_date = "calibration_data";
> 	//else
> 	//	cb_date = NULL;
> 	//if(cfg_->get_value("calibration_data_2", "0"))
> 	//	cb_date_2 = "calibration_data_2";
> 	//else
> 	//	cb_date_2 = NULL;
> 	//img_mask_ = build_mask(cb_date,cb_date_2);
147,163c147,163
<     bg.region_interval = fillbg_struct.body_width;
<     bg.time = fillbg_struct.continued_time_long;
<     bg.multiple_target_time = fillbg_struct.continued_time;
<     bg.slow_learn_rate = atof(cfg_->get_value("t_slow_learn_rate", "0.1"));
<     bg.fast_learn_rate = atof(cfg_->get_value("t_fast_learn_rate", "0.7"));
<     bg.region_num = masked_rect.width/bg.region_interval+1;
<     for(int i = 0;i<bg.region_num;i++)
<     {
<         Region temp;
<         reset_region(temp);
<         reset_static_region( temp );
<         Rect t = Rect(i*bg.region_interval,0,bg.region_interval,masked_rect.height);
<         t &= Rect(0,0,masked_rect.width,masked_rect.height);
<         temp.region = t;
<         temp.num = i;//0,1,2,...
<         bg.region.push_back(temp);
<     }
---
> 	bg.region_interval = fillbg_struct.body_width;
> 	bg.time = fillbg_struct.continued_time_long;
> 	bg.multiple_target_time = fillbg_struct.continued_time;
> 	bg.slow_learn_rate = atof(cfg_->get_value("t_slow_learn_rate", "0.1"));
> 	bg.fast_learn_rate = atof(cfg_->get_value("t_fast_learn_rate", "0.7"));
> 	bg.region_num = masked_rect.width/bg.region_interval+1;
> 	for(int i = 0;i<bg.region_num;i++)
> 	{
> 		Region temp;
> 		reset_region(temp);
> 		reset_static_region( temp );
> 		Rect t = Rect(i*bg.region_interval,0,bg.region_interval,masked_rect.height);
> 		t &= Rect(0,0,masked_rect.width,masked_rect.height);
> 		temp.region = t;
> 		temp.num = i;//0,1,2,...
> 		bg.region.push_back(temp);
> 	}
169,185c169,185
<     bg.region_interval = fillbg_struct.body_width;
<     bg.time = fillbg_struct.continued_time_long;
<     bg.multiple_target_time = fillbg_struct.continued_time;
<     bg.slow_learn_rate = atof(cfg_->get_value("t_slow_learn_rate", "0.1"));
<     bg.fast_learn_rate = atof(cfg_->get_value("t_fast_learn_rate", "0.5"));
<     bg.region_num = masked_rect.width/up_update.region_interval+1;
<     for(int i = 0;i<bg.region_num;i++)
<     {
<         Region temp;
<         reset_region(temp);
<         reset_static_region( temp );
<         Rect t = Rect(i*up_update.region_interval,0,up_update.region_interval,upbody_masked_rect.height);
<         //t &= Rect(0,0,masked_rect.width,upbody_masked_rect.height);
<         temp.region = t;
<         temp.num = i;//0,1,2,...
<         bg.region.push_back(temp);
<     }
---
> 	bg.region_interval = fillbg_struct.body_width;
> 	bg.time = fillbg_struct.continued_time_long;
> 	bg.multiple_target_time = fillbg_struct.continued_time;
> 	bg.slow_learn_rate = atof(cfg_->get_value("t_slow_learn_rate", "0.1"));
> 	bg.fast_learn_rate = atof(cfg_->get_value("t_fast_learn_rate", "0.5"));
> 	bg.region_num = masked_rect.width/up_update.region_interval+1;
> 	for(int i = 0;i<bg.region_num;i++)
> 	{
> 		Region temp;
> 		reset_region(temp);
> 		reset_static_region( temp );
> 		Rect t = Rect(i*up_update.region_interval,0,up_update.region_interval,upbody_masked_rect.height);
> 		//t &= Rect(0,0,masked_rect.width,upbody_masked_rect.height);
> 		temp.region = t;
> 		temp.num = i;//0,1,2,...
> 		bg.region.push_back(temp);
> 	}
192c192
<     return (a.width * a.height > b.width * b.height);
---
> 	return (a.width * a.height > b.width * b.height);
200,214c200,214
<     Rect rect_new;
<     int small_x = a.x;
<     int small_y = a.y;
<     int big_x = a.x + a.width;
<     int big_y = a.y + a.height;
<     if (b.x < small_x)
<         small_x = b.x;
<     if (b.y < small_y)
<         small_y = b.y;
<     if (b.x + b.width > big_x)
<         big_x = b.x + b.width;
<     if (b.y + b.height > big_y)
<         big_y = b.y + b.height;
<     rect_new = Rect(small_x, small_y, big_x - small_x, big_y - small_y);
<     return rect_new;
---
> 	Rect rect_new;
> 	int small_x = a.x;
> 	int small_y = a.y;
> 	int big_x = a.x + a.width;
> 	int big_y = a.y + a.height;
> 	if (b.x < small_x)
> 		small_x = b.x;
> 	if (b.y < small_y)
> 		small_y = b.y;
> 	if (b.x + b.width > big_x)
> 		big_x = b.x + b.width;
> 	if (b.y + b.height > big_y)
> 		big_y = b.y + b.height;
> 	rect_new = Rect(small_x, small_y, big_x - small_x, big_y - small_y);
> 	return rect_new;
220,261c220,261
<     //å¯¹è¿åŠ¨æ¡†å…ˆæŒ‰é¢ç§¯å¤§å°è¿›è¡Œæ’åºï¼Œç”±å¤§åˆ°å° ;
<     std::sort(seq.begin(), seq.end(), cmp_area);
<     Rect rect_i;
<     Rect rect_j;
<     int num = 0;
<     for (;;) {
<         std::vector < cv::Rect >::iterator it1;
<         std::vector < cv::Rect >::iterator it2;
<         num = 0;
<         for (it1 = seq.begin(); it1 != seq.end();)
<         {
<             for (it2 = it1 + 1; it2 != seq.end();)
<             {
<                 rect_i = *it1;
<                 rect_j = *it2;
<              if (((rect_i.x+interval) <(rect_j.x + rect_j.width)
<                 || (rect_i.x + rect_i.width ) >(rect_j.x+interval)
<                 ||(rect_i.y+fillbg_struct.body_width*4) <(rect_j.y + rect_j.height)
<                 || (rect_i.y + rect_i.height ) >(rect_j.y+fillbg_struct.body_width*4)) &&
<                 (rect_i.x >(rect_j.x + rect_j.width + 30)
<                     || (rect_i.x + rect_i.width + 30) <rect_j.x
<                     || rect_i.y >(rect_j.y + rect_j.height + fillbg_struct.body_width*2)
<                     || (rect_i.y + rect_i.height + fillbg_struct.body_width*2) <rect_j.y))
<                 {
<                     it2++;
<                     continue;
<                 } else  //å½“çŸ©å½¢æ¡†ä¹‹é—´æœ‰äº¤é›†æ—¶è¿›è¡Œèåˆ;
<                 {
<                     *it1 = sort_rect(rect_i, rect_j);
<                     it2 = seq.erase(it2);
<                     num++;
<                 }
<             }
<             it1++;
<         }
<         //å½“æ‰€æœ‰çŸ©å½¢æ¡†ä¹‹é—´ä¸å¯å†èåˆæ—¶åœæ­¢å¾ªç¯;
<         if (num == 0)
<         {
<             //é‡æ–°æŒ‰é¢ç§¯æ’åº;
<             std::sort(seq.begin(), seq.end(), cmp_area);
<             break;
<         }
---
> 	//å¯¹è¿åŠ¨æ¡†å…ˆæŒ‰é¢ç§¯å¤§å°è¿›è¡Œæ’åºï¼Œç”±å¤§åˆ°å° ;
> 	std::sort(seq.begin(), seq.end(), cmp_area);
> 	Rect rect_i;
> 	Rect rect_j;
> 	int num = 0;
> 	for (;;) {
> 		std::vector < cv::Rect >::iterator it1;
> 		std::vector < cv::Rect >::iterator it2;
> 		num = 0;
> 		for (it1 = seq.begin(); it1 != seq.end();) 
> 		{
> 			for (it2 = it1 + 1; it2 != seq.end();) 
> 			{
> 				rect_i = *it1;
> 				rect_j = *it2;
> 			 if (((rect_i.x+interval) <(rect_j.x + rect_j.width)
> 				|| (rect_i.x + rect_i.width ) >(rect_j.x+interval)
> 				||(rect_i.y+fillbg_struct.body_width*4) <(rect_j.y + rect_j.height)
> 				|| (rect_i.y + rect_i.height ) >(rect_j.y+fillbg_struct.body_width*4)) && 
> 				(rect_i.x >(rect_j.x + rect_j.width + 30)
> 				    || (rect_i.x + rect_i.width + 30) <rect_j.x
> 				    || rect_i.y >(rect_j.y + rect_j.height + fillbg_struct.body_width*2)
> 				    || (rect_i.y + rect_i.height + fillbg_struct.body_width*2) <rect_j.y))
> 				{
> 					it2++;
> 					continue;
> 				} else	//å½“çŸ©å½¢æ¡†ä¹‹é—´æœ‰äº¤é›†æ—¶è¿›è¡Œèåˆ;
> 				{
> 					*it1 = sort_rect(rect_i, rect_j);
> 					it2 = seq.erase(it2);
> 					num++;
> 				}
> 			}
> 			it1++;
> 		}
> 		//å½“æ‰€æœ‰çŸ©å½¢æ¡†ä¹‹é—´ä¸å¯å†èåˆæ—¶åœæ­¢å¾ªç¯;
> 		if (num == 0) 
> 		{
> 			//é‡æ–°æŒ‰é¢ç§¯æ’åº;
> 			std::sort(seq.begin(), seq.end(), cmp_area);
> 			break;
> 		}
263c263
<     }
---
> 	}
268,269c268,269
<                                Mat & dst,
<                                double interval,double marea,double mrect_area)
---
> 						       Mat & dst,
> 						       double interval,double marea,double mrect_area)
271,312c271,312
<     vector < Rect > rect;
<     int niters = 2;
<     vector < vector < Point > >contours;
<     vector < vector < Point > >contours_temp;
<     vector < Vec4i > hierarchy;
<     vector < Rect > right_rect;
<     Mat temp;
<     cv::dilate(mask, mask, cv::Mat());
<     cv::erode(mask, mask, cv::Mat());
<     //cv::erode(mask, mask, cv::Mat());
<     cv::dilate(mask, mask, cv::Mat(), cv::Point(-1, -1), 5);
< 
<     //å¦‚æœè¡Œæˆ–åˆ—æ˜¯å¥‡æ•°è¦åŠ ä¸€å˜æˆå¶æ•°å¤„ç†ï¼Œå› ä¸ºcvPyrUpå’ŒcvPyrDownåªæ”¯æŒå¶æ•°;
<     //IplImage* pyr=cvCreateImage(cvSize((mask.cols&-2)/2,(mask.rows&-2)/2),IPL_DEPTH_8U,1);
<     ////IplImage* pyr=cvCreateImage(cvSize(mask.cols/2,mask.rows/2),IPL_DEPTH_8U,1);
<     //cvPyrDown(&(IplImage)mask,pyr,CV_GAUSSIAN_5x5);
<     //cvDilate(pyr,pyr,0,1);
<     //cvPyrUp(pyr,&(IplImage)mask,CV_GAUSSIAN_5x5);
<     //cvReleaseImage(&pyr);
< 
<     //æ‰¾å‡ºç”»å‡ºè¶…è¿‡ä¸€å®šé¢ç§¯çš„è¿é€šåŒºåŸŸ;
<     findContours(mask, contours, hierarchy, CV_RETR_EXTERNAL,
<              CV_CHAIN_APPROX_SIMPLE);
<     dst = Mat::zeros(img.size(), CV_8UC3);
<     if (contours.size() > 0) {
<         Scalar color(255, 255, 255);
<         for (int idx = 0; idx < contours.size(); idx++) {
<             const vector < Point > &c = contours[idx];
<             Rect t = boundingRect(Mat(c));
<             double area = fabs(contourArea(Mat(c)));
<             if (area >= marea && (t.width*t.height)>=mrect_area)    //temp.rows*temp.cols/150)// &&
<             {
<                 contours_temp.push_back(contours[idx]);
<                 right_rect.push_back(t);
<             }
<         }
<         drawContours(dst, contours_temp, -1, color, CV_FILLED, 8);
<     }
<     if (right_rect.size() > 1) {
<         rect_fusion2(right_rect, interval);
<     }
<     return right_rect;
---
> 	vector < Rect > rect;
> 	int niters = 2;
> 	vector < vector < Point > >contours;
> 	vector < vector < Point > >contours_temp;
> 	vector < Vec4i > hierarchy;
> 	vector < Rect > right_rect;
> 	Mat temp;
> 	cv::dilate(mask, mask, cv::Mat());
> 	cv::erode(mask, mask, cv::Mat());
> 	//cv::erode(mask, mask, cv::Mat());
> 	cv::dilate(mask, mask, cv::Mat(), cv::Point(-1, -1), 5);
> 
> 	//å¦‚æœè¡Œæˆ–åˆ—æ˜¯å¥‡æ•°è¦åŠ ä¸€å˜æˆå¶æ•°å¤„ç†ï¼Œå› ä¸ºcvPyrUpå’ŒcvPyrDownåªæ”¯æŒå¶æ•°;
> 	//IplImage* pyr=cvCreateImage(cvSize((mask.cols&-2)/2,(mask.rows&-2)/2),IPL_DEPTH_8U,1);
> 	////IplImage* pyr=cvCreateImage(cvSize(mask.cols/2,mask.rows/2),IPL_DEPTH_8U,1);
> 	//cvPyrDown(&(IplImage)mask,pyr,CV_GAUSSIAN_5x5);
> 	//cvDilate(pyr,pyr,0,1);
> 	//cvPyrUp(pyr,&(IplImage)mask,CV_GAUSSIAN_5x5);
> 	//cvReleaseImage(&pyr);
> 
> 	//æ‰¾å‡ºç”»å‡ºè¶…è¿‡ä¸€å®šé¢ç§¯çš„è¿é€šåŒºåŸŸ;
> 	findContours(mask, contours, hierarchy, CV_RETR_EXTERNAL,
> 		     CV_CHAIN_APPROX_SIMPLE);
> 	dst = Mat::zeros(img.size(), CV_8UC3);
> 	if (contours.size() > 0) {
> 		Scalar color(255, 255, 255);
> 		for (int idx = 0; idx < contours.size(); idx++) {
> 			const vector < Point > &c = contours[idx];
> 			Rect t = boundingRect(Mat(c));
> 			double area = fabs(contourArea(Mat(c)));
> 			if (area >= marea && (t.width*t.height)>=mrect_area)	//temp.rows*temp.cols/150)// && 
> 			{
> 				contours_temp.push_back(contours[idx]);
> 				right_rect.push_back(t);
> 			}
> 		}
> 		drawContours(dst, contours_temp, -1, color, CV_FILLED, 8);
> 	}
> 	if (right_rect.size() > 1) {
> 		rect_fusion2(right_rect, interval);
> 	}
> 	return right_rect;
318,319c318,319
<                                Mat & dst,
<                                double interval,double marea,double mrect_area)
---
> 						       Mat & dst,
> 						       double interval,double marea,double mrect_area)
321,355c321,355
<     vector < Rect > rect;
<     int niters = 2;
<     vector < vector < Point > >contours;
<     vector < vector < Point > >contours_temp;
<     vector < Vec4i > hierarchy;
<     vector < Rect > right_rect;
<     Mat temp;
<     //cv::erode(mask, mask, cv::Mat());
<     cv::dilate(mask, mask, cv::Mat());
<     cv::erode(mask, mask, cv::Mat());
<     //cv::erode(mask, mask, cv::Mat());
<     cv::dilate(mask, mask, cv::Mat(), cv::Point(-1, -1), 5);
< 
<     //æ‰¾å‡ºç”»å‡ºè¶…è¿‡ä¸€å®šé¢ç§¯çš„è¿é€šåŒºåŸŸ;
<     findContours(mask, contours, hierarchy, CV_RETR_EXTERNAL,
<              CV_CHAIN_APPROX_SIMPLE);
<     dst = Mat::zeros(img.size(), CV_8UC3);
<     if (contours.size() > 0) {
<         Scalar color(255, 255, 255);
<         for (int idx = 0; idx < contours.size(); idx++) {
<             const vector < Point > &c = contours[idx];
<             Rect t = boundingRect(Mat(c));
<             double area = fabs(contourArea(Mat(c)));
<             if (t.width*t.height >= mrect_area) //temp.rows*temp.cols/150)// &&
<             {
<                 contours_temp.push_back(contours[idx]);
<                 right_rect.push_back(t);
<             }
<         }
<         drawContours(dst, contours_temp, -1, color, CV_FILLED, 8);
<     }
<     if (right_rect.size() > 1) {
<         rect_fusion2(right_rect, interval);
<     }
<     return right_rect;
---
> 	vector < Rect > rect;
> 	int niters = 2;
> 	vector < vector < Point > >contours;
> 	vector < vector < Point > >contours_temp;
> 	vector < Vec4i > hierarchy;
> 	vector < Rect > right_rect;
> 	Mat temp;
> 	//cv::erode(mask, mask, cv::Mat());
> 	cv::dilate(mask, mask, cv::Mat());
> 	cv::erode(mask, mask, cv::Mat());
> 	//cv::erode(mask, mask, cv::Mat());
> 	cv::dilate(mask, mask, cv::Mat(), cv::Point(-1, -1), 5);
> 
> 	//æ‰¾å‡ºç”»å‡ºè¶…è¿‡ä¸€å®šé¢ç§¯çš„è¿é€šåŒºåŸŸ;
> 	findContours(mask, contours, hierarchy, CV_RETR_EXTERNAL,
> 		     CV_CHAIN_APPROX_SIMPLE);
> 	dst = Mat::zeros(img.size(), CV_8UC3);
> 	if (contours.size() > 0) {
> 		Scalar color(255, 255, 255);
> 		for (int idx = 0; idx < contours.size(); idx++) {
> 			const vector < Point > &c = contours[idx];
> 			Rect t = boundingRect(Mat(c));
> 			double area = fabs(contourArea(Mat(c)));
> 			if (t.width*t.height >= mrect_area)	//temp.rows*temp.cols/150)// && 
> 			{
> 				contours_temp.push_back(contours[idx]);
> 				right_rect.push_back(t);
> 			}
> 		}
> 		drawContours(dst, contours_temp, -1, color, CV_FILLED, 8);
> 	}
> 	if (right_rect.size() > 1) {
> 		rect_fusion2(right_rect, interval);
> 	}
> 	return right_rect;
361,414c361,414
<     //è·å–è“æ¡†;
<     if(fillbg_struct.rect_old.size()== 1 && fillbg_struct.nframe == 0)
<     {
<         if(fillbg_struct.rect_old[0].width<3*fillbg_struct.body_width)
<         {
<             Rect r;
<             //fillbg_struct.bg = img.clone();
<             //fillbg_struct.fist_fillrect_t = fillbg_struct.rect_old;
<             //å½“å‡ºç°çš„çŸ©å½¢å°äºå®šä¹‰çš„å¯èƒ½å‡ºç°çš„çŸ©å½¢æœ€å¤§æ¡†æ—¶æ­£å¸¸å¤„ç†;
<             Rect t = fillbg_struct.rect_old[0];
<             r = Rect(t.x+t.width/2-(fillbg_struct.body_width-20),t.y+t.height/2-2*fillbg_struct.body_width,
<                 2*(fillbg_struct.body_width+20),4*fillbg_struct.body_width);
<             r &= Rect(0, 0, img.cols, img.rows);
<             fillbg_struct.fist_fillrect.push_back(r);
<             //fillbg_struct.fist_fillrect_noclear.push_back(r);
<             fillbg_struct.nframe = 2;
<         }
<         else
<         {
<             fillbg_struct.bg = img.clone();
<         }
<     }
<     if(fillbg_struct.nframe == 2)
<     {
<         //eliminate_longrect(img);
<         bool flag = false;
<         for(int i = 0;i<fillbg_struct.rect_old.size();i++)
<         {
<             Rect t = fillbg_struct.rect_old[i];
<             Rect t_f = fillbg_struct.fist_fillrect[0];
<             //if((t.x+t.width)<(t_f.x-fillbg_struct.second_interval)||t.x>(t_f.x+t_f.width+fillbg_struct.second_interval))
<             if((t.x+t.width)<(t_f.x)||t.x>(t_f.x+t_f.width))
<             {
<                 flag = true;continue;
<             }
<             else
<             {
<                 flag = false;break;
<             }
<         }
<         if(flag)//å¯ä»¥è¿›è¡Œæ›´æ–°å•¦;
<         {
<             Mat mask(img.rows, img.cols, CV_8UC3,
<                     Scalar(0, 0, 0));
<             Rect r_temp = fillbg_struct.fist_fillrect[0];
<             r_temp &= Rect(0, 0, img.cols, img.rows);
<             Mat specified(mask, r_temp);
<             specified.setTo(1);
<             img.copyTo(fillbg_struct.bg, mask);
<             fillbg_struct.nframe = 3;
<             fillbg_struct.isfillok = true;
<             //fillbg_struct.fist_fillrect.clear();
<         }
<     }
---
> 	//è·å–è“æ¡†;
> 	if(fillbg_struct.rect_old.size()== 1 && fillbg_struct.nframe == 0)
> 	{
> 		if(fillbg_struct.rect_old[0].width<3*fillbg_struct.body_width)
> 		{
> 			Rect r;
> 			//fillbg_struct.bg = img.clone();
> 			//fillbg_struct.fist_fillrect_t = fillbg_struct.rect_old;
> 			//å½“å‡ºç°çš„çŸ©å½¢å°äºå®šä¹‰çš„å¯èƒ½å‡ºç°çš„çŸ©å½¢æœ€å¤§æ¡†æ—¶æ­£å¸¸å¤„ç†; 	
> 			Rect t = fillbg_struct.rect_old[0];
> 			r = Rect(t.x+t.width/2-(fillbg_struct.body_width-20),t.y+t.height/2-2*fillbg_struct.body_width,
> 				2*(fillbg_struct.body_width+20),4*fillbg_struct.body_width);
> 			r &= Rect(0, 0, img.cols, img.rows);
> 			fillbg_struct.fist_fillrect.push_back(r);
> 			//fillbg_struct.fist_fillrect_noclear.push_back(r);
> 			fillbg_struct.nframe = 2;
> 		}
> 		else
> 		{
> 			fillbg_struct.bg = img.clone();
> 		}
> 	}
> 	if(fillbg_struct.nframe == 2)
> 	{	
> 		//eliminate_longrect(img);
> 		bool flag = false;
> 		for(int i = 0;i<fillbg_struct.rect_old.size();i++)
> 		{
> 			Rect t = fillbg_struct.rect_old[i];
> 			Rect t_f = fillbg_struct.fist_fillrect[0];
> 			//if((t.x+t.width)<(t_f.x-fillbg_struct.second_interval)||t.x>(t_f.x+t_f.width+fillbg_struct.second_interval))
> 			if((t.x+t.width)<(t_f.x)||t.x>(t_f.x+t_f.width))
> 			{
> 				flag = true;continue;
> 			}
> 			else
> 			{
> 				flag = false;break;
> 			}				
> 		}
> 		if(flag)//å¯ä»¥è¿›è¡Œæ›´æ–°å•¦;
> 		{	
> 			Mat mask(img.rows, img.cols, CV_8UC3,
> 					Scalar(0, 0, 0));
> 			Rect r_temp = fillbg_struct.fist_fillrect[0];
> 			r_temp &= Rect(0, 0, img.cols, img.rows);
> 			Mat specified(mask, r_temp);
> 			specified.setTo(1);
> 			img.copyTo(fillbg_struct.bg, mask);
> 			fillbg_struct.nframe = 3;
> 			fillbg_struct.isfillok = true;
> 			//fillbg_struct.fist_fillrect.clear();
> 		}		
> 	}
422,452c422,452
<     //åˆ¤æ–­è“æ¡†å¤–æ˜¯å¦æ˜¯è¿ç»­5æ¬¡å•ç›®æ ‡(è¿™æ˜¯åˆ¤æ–­è“æ¡†æ˜¯å¦æ›´æ–°å¯¹çš„ä¸€ä¸ªä¾æ®);
<     if(fillbg_struct.nframe == 3 && fillbg_struct.rect_old.size() == 1 && !fillbg_struct.isfillok_end)
<     {
<         Rect r = fillbg_struct.rect_old[0];
<         Rect r_first = fillbg_struct.fist_fillrect[0];
<         //åªæœ‰ä¸€ä¸ªçŸ©å½¢ä¸”çŸ©å½¢åœ¨åŸå§‹è“æ¡†èŒƒå›´å¤–åˆ™è¡¨æ˜æ²¡æœ‰é”™è¯¯æ›´æ–°;
<         if((r.x>=(r_first.x+r_first.width+10)) ||((r.x+r.width)<=(r_first.x-10)))
<         {
<             fillbg_struct.filltwice_num++;
<             if (atoi(cfg_->get_value("debug", "0")) > 0)
<             {fprintf(stderr,"%d\n",fillbg_struct.filltwice_num);}
<         }
<         if(fillbg_struct.filltwice_num>=5)
<         {
<             fillbg_struct.isfillok_end = true;
<             fillbg_struct.filltwice_num = 0;
<         }
< 
<     }
<     ////é™æ­¢ç›®æ ‡æ¡†æ›´æ–°è¿‡ä¹‹åæ²¡æœ‰ç›®æ ‡äº†çš„è¯ï¼Œé‚£è¡¨æ˜å¯èƒ½æ˜¯é”™è¯¯æ›´æ–°ï¼ˆæŠŠé™æ­¢çš„äººç»™è¯¯æ›´æ–°å•¦ï¼‰;
<     //if(fillbg_struct.ud_static_begain && fillbg_struct.rect_old.size() == 0)
<     //{
<     //  fillbg_struct.ud_static_begain = false;
<     //  fillbg_struct.bg = img.clone();
<     //  fillbg_struct.nframe = 0;
<     //  fillbg_struct.isfillok = false;
<     //  fillbg_struct.isfillok_end = false;
<     //  fillbg_struct.bg = img.clone();
<     //  fillbg_struct.fist_fillrect.clear();
<     //  fillbg_struct.filltwice_num = 0;
<     //}
---
> 	//åˆ¤æ–­è“æ¡†å¤–æ˜¯å¦æ˜¯è¿ç»­5æ¬¡å•ç›®æ ‡(è¿™æ˜¯åˆ¤æ–­è“æ¡†æ˜¯å¦æ›´æ–°å¯¹çš„ä¸€ä¸ªä¾æ®);
> 	if(fillbg_struct.nframe == 3 && fillbg_struct.rect_old.size() == 1 && !fillbg_struct.isfillok_end)
> 	{
> 		Rect r = fillbg_struct.rect_old[0];
> 		Rect r_first = fillbg_struct.fist_fillrect[0];
> 		//åªæœ‰ä¸€ä¸ªçŸ©å½¢ä¸”çŸ©å½¢åœ¨åŸå§‹è“æ¡†èŒƒå›´å¤–åˆ™è¡¨æ˜æ²¡æœ‰é”™è¯¯æ›´æ–°;
> 		if((r.x>=(r_first.x+r_first.width+10)) ||((r.x+r.width)<=(r_first.x-10)))
> 		{
> 			fillbg_struct.filltwice_num++;
> 			if (atoi(cfg_->get_value("debug", "0")) > 0)
> 			{fprintf(stderr,"%d\n",fillbg_struct.filltwice_num);}		
> 		}
> 		if(fillbg_struct.filltwice_num>=5)
> 		{
> 			fillbg_struct.isfillok_end = true;
> 			fillbg_struct.filltwice_num = 0;
> 		}
> 		
> 	}
> 	////é™æ­¢ç›®æ ‡æ¡†æ›´æ–°è¿‡ä¹‹åæ²¡æœ‰ç›®æ ‡äº†çš„è¯ï¼Œé‚£è¡¨æ˜å¯èƒ½æ˜¯é”™è¯¯æ›´æ–°ï¼ˆæŠŠé™æ­¢çš„äººç»™è¯¯æ›´æ–°å•¦ï¼‰;
> 	//if(fillbg_struct.ud_static_begain && fillbg_struct.rect_old.size() == 0)
> 	//{
> 	//	fillbg_struct.ud_static_begain = false;
> 	//	fillbg_struct.bg = img.clone();
> 	//	fillbg_struct.nframe = 0;
> 	//	fillbg_struct.isfillok = false;
> 	//	fillbg_struct.isfillok_end = false;
> 	//	fillbg_struct.bg = img.clone();
> 	//	fillbg_struct.fist_fillrect.clear();
> 	//	fillbg_struct.filltwice_num = 0;
> 	//}
459,474c459,474
< //  if(fillbg_struct.rect_old.size() > 0)
< //  {
< //      fillbg_struct.no_rect.pre_time = fillbg_struct.no_rect.cur_time = clock();
< //  }
< //  if(fillbg_struct.rect_old.size() == 0)
< //  {
< //      fillbg_struct.no_rect.cur_time = clock();
< //      fillbg_struct.no_rect.continued_time = double(fillbg_struct.no_rect.cur_time-fillbg_struct.no_rect.pre_time)/CLOCKS_PER_SEC;
< //      if(fillbg_struct.no_rect.continued_time>fillbg_struct.norect_update_time)
< //      {
< //          //æ›´æ–°æ•´ä¸ªèƒŒæ™¯.
< //          //Mat mask(img.rows,img.cols, CV_8UC3, Scalar(0,0,0));
< //          img.copyTo(fillbg_struct.bg,img);
< //          fillbg_struct.no_rect.pre_time = fillbg_struct.no_rect.cur_time = clock();
< //      }
< //  }
---
> //	if(fillbg_struct.rect_old.size() > 0)
> //	{
> //		fillbg_struct.no_rect.pre_time = fillbg_struct.no_rect.cur_time = clock();  
> //	}
> //	if(fillbg_struct.rect_old.size() == 0)
> //	{
> //		fillbg_struct.no_rect.cur_time = clock(); 
> //		fillbg_struct.no_rect.continued_time = double(fillbg_struct.no_rect.cur_time-fillbg_struct.no_rect.pre_time)/CLOCKS_PER_SEC;
> //		if(fillbg_struct.no_rect.continued_time>fillbg_struct.norect_update_time)
> //		{
> //			//æ›´æ–°æ•´ä¸ªèƒŒæ™¯.
> //			//Mat mask(img.rows,img.cols, CV_8UC3, Scalar(0,0,0));
> //			img.copyTo(fillbg_struct.bg,img);
> //			fillbg_struct.no_rect.pre_time = fillbg_struct.no_rect.cur_time = clock();  		
> //		}
> //	}
482,514c482,514
< //      std::vector<Rect> temp;
< //      if(fillbg_struct.rect_old.size()>fillbg_struct.fist_fillrect_original.size())
< //      {
< //          for(int i = 0;i<fillbg_struct.rect_old.size();i++)
< //          {
< //              Rect t = fillbg_struct.rect_old[i];
< //              Rect t_f = fillbg_struct.fist_fillrect_original[0];
< //              t_f.x = t_f.x+(t_f.width*3.0/8.0);t_f.width = t_f.width/4.0;
< //              if((t.x+t.width)<t_f.x||t.x>(t_f.x+t_f.width))
< //                  temp.push_back(t);
< //          }
< //          if(temp.size()>0)
< //          {
< //              fillbg_struct.rect_old.clear();
< //              fillbg_struct.rect_old = temp;
< //          }
< //          else//èåˆèµ·æ¥.
< //          {
< //              double x_max=0, y_max=0, x_min=img.cols, y_min=img.rows;
< //              for(int i = 0;i<fillbg_struct.rect_old.size();i++)
< //              {
< //                  Rect t = fillbg_struct.rect_old[i];
< //                  if(x_max<(t.x+t.width)) x_max = t.x+t.width;
< //                  if(y_max<(t.y+t.height)) y_max = t.y+t.height;
< //                  if(x_min>t.x) x_min = t.x;
< //                  if(y_min>t.y) y_min = t.y;
< //              }
< //              Rect r = Rect(x_min,y_min,abs(x_max-x_min),abs(y_max-y_min));
< //              r &= Rect(0,0,img.cols,img.rows);
< //              fillbg_struct.rect_old.clear();
< //              fillbg_struct.rect_old.push_back(r);
< //          }
< //      }
---
> //		std::vector<Rect> temp;
> //		if(fillbg_struct.rect_old.size()>fillbg_struct.fist_fillrect_original.size())
> //		{
> //			for(int i = 0;i<fillbg_struct.rect_old.size();i++)
> //			{
> //				Rect t = fillbg_struct.rect_old[i];
> //				Rect t_f = fillbg_struct.fist_fillrect_original[0];
> //				t_f.x = t_f.x+(t_f.width*3.0/8.0);t_f.width = t_f.width/4.0;
> //				if((t.x+t.width)<t_f.x||t.x>(t_f.x+t_f.width))
> //					temp.push_back(t);
> //			}
> //			if(temp.size()>0)
> //			{
> //				fillbg_struct.rect_old.clear();
> //				fillbg_struct.rect_old = temp;
> //			}
> //			else//èåˆèµ·æ¥.
> //			{
> //				double x_max=0, y_max=0, x_min=img.cols, y_min=img.rows;
> //				for(int i = 0;i<fillbg_struct.rect_old.size();i++)
> //				{
> //					Rect t = fillbg_struct.rect_old[i];
> //					if(x_max<(t.x+t.width)) x_max = t.x+t.width;
> //					if(y_max<(t.y+t.height)) y_max = t.y+t.height;
> //					if(x_min>t.x) x_min = t.x;
> //					if(y_min>t.y) y_min = t.y;
> //				}
> //				Rect r = Rect(x_min,y_min,abs(x_max-x_min),abs(y_max-y_min));
> //				r &= Rect(0,0,img.cols,img.rows);
> //				fillbg_struct.rect_old.clear();
> //				fillbg_struct.rect_old.push_back(r);
> //			}
> //		}
521,591c521,591
<     Mat luv_m,luv_m_temp,fgimg;//èƒŒæ™¯å‡é™¤;
<     luv_m.create(Size(img.cols, img.rows), CV_8UC1);
<     luv_m.setTo(0);
<     luv_m_temp = img.clone();
<     luv_m_temp.setTo(Scalar::all(255));
<     Mat img_t; Mat bg_t;
<     /*cvtColor(img, img_t, CV_BGR2Luv);
<     cvtColor(fillbg_struct.bg, bg_t, CV_BGR2Luv);*/
<     cvtColor(img, img_t, CV_BGR2YUV);
<     cvtColor(up_update.upbody_bg, bg_t, CV_BGR2YUV);
< 
<     /*std::vector<Mat> img_t_vec;
<     split(img_t,img_t_vec);
<     Mat img0 = img_t_vec[0];Mat img1 = img_t_vec[1];Mat img2 = img_t_vec[2];
<     std::vector<Mat> bg_t_vec;
<     cv::split(bg_t,bg_t_vec);
<     Mat bg0 = bg_t_vec[0];Mat bg1 = bg_t_vec[1];Mat bg2 = bg_t_vec[2];
<     Mat yuv0,yuv1,yuv2;
<     cv::absdiff(img0,bg0,yuv0);
<     cv::absdiff(img1,bg1,yuv1);
<     cv::absdiff(img2,bg2,yuv2);
<     Mat luv0,luv1,luv2;
<     cv::threshold(yuv0,luv0,up_update.Y_value,255,CV_THRESH_BINARY);
<     cv::threshold(yuv1,luv1,up_update.upbody_u_max,255,CV_THRESH_BINARY);
<     cv::threshold(yuv2,luv2,up_update.upbody_v_max,255,CV_THRESH_BINARY);
<     Mat luv_temp;
<     bitwise_or(luv0,luv1,luv_temp);
<     bitwise_or(luv2,luv_temp,luv_m);*/
< 
< 
<     for (int i = 0; i < img.cols; i++)
<     {
<         for (int j = 0; j < img.rows; j++)
<         {
<             Vec3b bgr1 = img_t.at < Vec3b > (j, i);
<             Vec3b bgr2 = bg_t.at < Vec3b > (j, i);
<             double L =
<                 (abs) (bgr1.val[0] - bgr2.val[0]);
<             double U =
<                 (abs) (bgr1.val[1] - bgr2.val[1]);
<             double V =
<                 (abs) ((bgr1.val[2] - bgr2.val[2]));
<             if ((U >= up_update.upbody_u_max || V >= up_update.upbody_v_max)&&(L >= up_update.Y_value))
<             {
<                 luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(0,0,0);
<             }
<             else if ((U >= up_update.upbody_u_max || V >= up_update.upbody_v_max)&&(L < up_update.Y_value))
<             {
<                 luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(0,0,255);
<             }
<             else if ((U < up_update.upbody_u_max && V < up_update.upbody_v_max)&&(L > up_update.Y_value))
<             {
<                 luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(255,0,0);
<             }
<             else
<             {
<                 luv_m.at < char >(j, i) = 0;
<             }
< 
<         }
<     }
< 
<     up_update.upbody_rect =
<         upbody_refineSegments2(img, luv_m, fgimg,
<                 fillbg_struct.mog2_interval2,up_update.min_area,up_update.min_rect_area);
<     if(atoi(cfg_->get_value("debug","0"))>0)
<     {
<         //imshow("upbody_fgimg",fgimg);
<         imshow("upbody_luv_m_temp",luv_m_temp);
<         waitKey(1);
<     }
---
> 	Mat luv_m,luv_m_temp,fgimg;//èƒŒæ™¯å‡é™¤;
> 	luv_m.create(Size(img.cols, img.rows), CV_8UC1);
> 	luv_m.setTo(0);
> 	luv_m_temp = img.clone();
> 	luv_m_temp.setTo(Scalar::all(255));
> 	Mat img_t; Mat bg_t;
> 	/*cvtColor(img, img_t, CV_BGR2Luv);
> 	cvtColor(fillbg_struct.bg, bg_t, CV_BGR2Luv);*/
> 	cvtColor(img, img_t, CV_BGR2YUV);
> 	cvtColor(up_update.upbody_bg, bg_t, CV_BGR2YUV);
> 	
> 	/*std::vector<Mat> img_t_vec;
> 	split(img_t,img_t_vec);
> 	Mat img0 = img_t_vec[0];Mat img1 = img_t_vec[1];Mat img2 = img_t_vec[2];
> 	std::vector<Mat> bg_t_vec;
> 	cv::split(bg_t,bg_t_vec);
> 	Mat bg0 = bg_t_vec[0];Mat bg1 = bg_t_vec[1];Mat bg2 = bg_t_vec[2];
> 	Mat yuv0,yuv1,yuv2;
> 	cv::absdiff(img0,bg0,yuv0);
> 	cv::absdiff(img1,bg1,yuv1);
> 	cv::absdiff(img2,bg2,yuv2);
> 	Mat luv0,luv1,luv2;
> 	cv::threshold(yuv0,luv0,up_update.Y_value,255,CV_THRESH_BINARY);
> 	cv::threshold(yuv1,luv1,up_update.upbody_u_max,255,CV_THRESH_BINARY);
> 	cv::threshold(yuv2,luv2,up_update.upbody_v_max,255,CV_THRESH_BINARY);
> 	Mat luv_temp;
> 	bitwise_or(luv0,luv1,luv_temp);
> 	bitwise_or(luv2,luv_temp,luv_m);*/
> 
> 
> 	for (int i = 0; i < img.cols; i++) 
> 	{
> 		for (int j = 0; j < img.rows; j++) 
> 		{
> 			Vec3b bgr1 = img_t.at < Vec3b > (j, i);
> 			Vec3b bgr2 = bg_t.at < Vec3b > (j, i);
> 			double L =
> 				(abs) (bgr1.val[0] - bgr2.val[0]);
> 			double U =
> 				(abs) (bgr1.val[1] - bgr2.val[1]);
> 			double V =
> 				(abs) ((bgr1.val[2] - bgr2.val[2]));
> 			if ((U >= up_update.upbody_u_max || V >= up_update.upbody_v_max)&&(L >= up_update.Y_value))
> 			{
> 				luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(0,0,0);
> 			}
> 			else if ((U >= up_update.upbody_u_max || V >= up_update.upbody_v_max)&&(L < up_update.Y_value))
> 			{
> 				luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(0,0,255);
> 			}
> 			else if ((U < up_update.upbody_u_max && V < up_update.upbody_v_max)&&(L > up_update.Y_value))
> 			{
> 				luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(255,0,0);
> 			}
> 			else
> 			{
> 				luv_m.at < char >(j, i) = 0;
> 			}
> 		   
> 		}
> 	}
> 
> 	up_update.upbody_rect =
> 		upbody_refineSegments2(img, luv_m, fgimg,
> 				fillbg_struct.mog2_interval2,up_update.min_area,up_update.min_rect_area);
> 	if(atoi(cfg_->get_value("debug","0"))>0)
> 	{
> 		//imshow("upbody_fgimg",fgimg);
> 		imshow("upbody_luv_m_temp",luv_m_temp);
> 		waitKey(1);
> 	}
597,647c597,647
<     Mat luv_m,luv_m_temp,fgimg;//èƒŒæ™¯å‡é™¤;
<     luv_m.create(Size(img.cols, img.rows), CV_8UC1);
<     luv_m.setTo(0);
<     luv_m_temp = img.clone();
<     luv_m_temp.setTo(Scalar::all(255));
<     Mat img_t; Mat bg_t;
<     /*cvtColor(img, img_t, CV_BGR2Luv);
<     cvtColor(fillbg_struct.bg, bg_t, CV_BGR2Luv);*/
<     cvtColor(img, img_t, CV_BGR2YUV);
<     cvtColor(fillbg_struct.bg, bg_t, CV_BGR2YUV);
<     for (int i = 0; i < img.cols; i++)
<     {
<         for (int j = 0; j < img.rows; j++)
<         {
<             Vec3b bgr1 = img_t.at < Vec3b > (j, i);
<             Vec3b bgr2 = bg_t.at < Vec3b > (j, i);
<             double L =
<                 (abs) (bgr1.val[0] - bgr2.val[0]);
<             double U =
<                 (abs) (bgr1.val[1] - bgr2.val[1]);
<             double V =
<                 (abs) ((bgr1.val[2] - bgr2.val[2]));
<             if ((U >= luv_u_max || V >= luv_v_max)&&(L >= luv_L))
<             {
<                 luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(0,0,0);
<             }
<             else if ((U >= luv_u_max || V >= luv_v_max)&&(L < luv_L))
<             {
<                 luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(0,0,255);
<             }
<             else if ((U < luv_u_max && V < luv_v_max)&&(L > luv_L))
<             {
<                 luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(255,0,0);
<             }
<             else
<             {
<                 luv_m.at < char >(j, i) = 0;
<             }
< 
<         }
<     }
< 
<     fillbg_struct.rect_old =
<         refineSegments2(img, luv_m, fgimg,
<                 fillbg_struct.mog2_interval2,min_area,min_rect_area);
<     if(atoi(cfg_->get_value("debug","0"))>0)
<     {
<         //imshow("fgimg",fgimg);
<         imshow("luv_m_temp",luv_m_temp);
<         waitKey(1);
<     }
---
> 	Mat luv_m,luv_m_temp,fgimg;//èƒŒæ™¯å‡é™¤;
> 	luv_m.create(Size(img.cols, img.rows), CV_8UC1);
> 	luv_m.setTo(0);
> 	luv_m_temp = img.clone();
> 	luv_m_temp.setTo(Scalar::all(255));
> 	Mat img_t; Mat bg_t;
> 	/*cvtColor(img, img_t, CV_BGR2Luv);
> 	cvtColor(fillbg_struct.bg, bg_t, CV_BGR2Luv);*/
> 	cvtColor(img, img_t, CV_BGR2YUV);
> 	cvtColor(fillbg_struct.bg, bg_t, CV_BGR2YUV);
> 	for (int i = 0; i < img.cols; i++) 
> 	{
> 		for (int j = 0; j < img.rows; j++) 
> 		{
> 			Vec3b bgr1 = img_t.at < Vec3b > (j, i);
> 			Vec3b bgr2 = bg_t.at < Vec3b > (j, i);
> 			double L =
> 				(abs) (bgr1.val[0] - bgr2.val[0]);
> 			double U =
> 				(abs) (bgr1.val[1] - bgr2.val[1]);
> 			double V =
> 				(abs) ((bgr1.val[2] - bgr2.val[2]));
> 			if ((U >= luv_u_max || V >= luv_v_max)&&(L >= luv_L))
> 			{
> 				luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(0,0,0);
> 			}
> 			else if ((U >= luv_u_max || V >= luv_v_max)&&(L < luv_L))
> 			{
> 				luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(0,0,255);
> 			}
> 			else if ((U < luv_u_max && V < luv_v_max)&&(L > luv_L))
> 			{
> 				luv_m.at < char >(j, i) = 255; luv_m_temp.at < Vec3b >(j, i) = Vec3b(255,0,0);
> 			}
> 			else
> 			{
> 				luv_m.at < char >(j, i) = 0;
> 			}
> 		   
> 		}
> 	}
> 
> 	fillbg_struct.rect_old =
> 		refineSegments2(img, luv_m, fgimg,
> 				fillbg_struct.mog2_interval2,min_area,min_rect_area);
> 	if(atoi(cfg_->get_value("debug","0"))>0)
> 	{
> 		//imshow("fgimg",fgimg);
> 		imshow("luv_m_temp",luv_m_temp);
> 		waitKey(1);
> 	}
656,726c656,726
<         Rect t = fillbg_struct.fist_fillrect[0];
<         Rect temp = Rect(t.x-50,masked_rect.y,t.width+50*2,masked_rect.height+(video_width_/480.0)*30);
<         temp &= Rect(0,0,raw_img.cols,raw_img.rows);
<         for(int k = 0;k<frame_s.frame_rect.size();k++)
<         {
<             if(
<             frame_s.frame_rect[k].y>(masked_rect.y+masked_rect.height+(video_width_/480.0)*10)
<             &&frame_s.frame_rect[k].y<(masked_rect.y+masked_rect.height+frame_s.bottom_inter)
<             &&frame_s.frame_rect[k].x>=temp.x
<             &&(frame_s.frame_rect[k].x+frame_s.frame_rect[k].width)<=(temp.x+temp.width))//&& frame_s.frame_rect.size()==1
<             {
<                 frame_s.is_body_down = true;
<                 fprintf(stderr,"teacher is down!\n");
<                 break;
<             }
<         }
<         bool no_rect = false;
<         //å…¨å±€éƒ½æ²¡æœ‰çŸ©å½¢æ¡†;
<         if(frame_s.frame_rect.size()<=0)
<             no_rect = true;
<         else//ç»™å®šçš„çŸ©å½¢æ¡†å†…æ²¡æœ‰mogçŸ©å½¢;
<         {
<             bool flag = true;
<             for(int i = 0;i<frame_s.frame_rect.size();i++)
<             {
<                 Rect m_r = frame_s.frame_rect[i];
<                 if( (m_r.x+m_r.width)<(temp.x) || m_r.x>(temp.x+temp.width)
<                     || (m_r.y+m_r.height)<(temp.y) || m_r.y>(temp.y+temp.height))
<                 {continue;}
<                 else
<                 {
<                     flag = false;break;
<                 }
<             }
<             if(flag)
<             {no_rect = true;}
<         }
<         if( no_rect && frame_s.is_body_down)
<         {
<             if(!fillbg_struct.mog2_s.flag)
<             {
<                 fillbg_struct.mog2_s.cur_time = fillbg_struct.mog2_s.pre_time = clock();
<                 fillbg_struct.mog2_s.flag = true;
<             }
<             else
<             {
<                 fillbg_struct.mog2_s.cur_time = clock();
<             }
<         }
<         else
<         {
<             fillbg_struct.mog2_s.cur_time = fillbg_struct.mog2_s.pre_time = clock();
<             frame_s.is_body_down = false;
<             fillbg_struct.mog2_s.flag = false;
<         }
<         double interval_t =((double)(fillbg_struct.mog2_s.cur_time - fillbg_struct.mog2_s.pre_time) / CLOCKS_PER_SEC);
< 
<         if(atoi(cfg_->get_value("debug","0"))>0)
<         {
<             if(interval_t>0)
<             {fprintf(stderr,"teacher_down_time = %f\n",interval_t);}
<         }
<         //æ›´æ–°è“æ¡†åŒºåŸŸèƒŒæ™¯;
<         if(interval_t>fillbg_struct.mog2_s.continued_time)
<         {
<             fillbg_struct.mog2_s.cur_time = fillbg_struct.mog2_s.pre_time = clock();
<             updatebg(img2,fillbg_struct.fist_fillrect[0]);
<             //è¿™ä¸ªåœ°æ–¹æœ‰å¾…æ”¹è¿›ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼ˆä¸èƒ½ç›´æ¥å°±è¿™ä¹ˆç®—äº†ï¼‰;
<             fillbg_struct.nframe = 3;
<             fillbg_struct.isfillok = true;
<             //fillbg_struct.fist_fillrect.clear();
---
> 	    Rect t = fillbg_struct.fist_fillrect[0];
> 	    Rect temp = Rect(t.x-50,masked_rect.y,t.width+50*2,masked_rect.height+(video_width_/480.0)*30);
> 	    temp &= Rect(0,0,raw_img.cols,raw_img.rows);
> 		for(int k = 0;k<frame_s.frame_rect.size();k++)
> 		{
> 			if( 
> 			frame_s.frame_rect[k].y>(masked_rect.y+masked_rect.height+(video_width_/480.0)*10)
> 			&&frame_s.frame_rect[k].y<(masked_rect.y+masked_rect.height+frame_s.bottom_inter) 
> 			&&frame_s.frame_rect[k].x>=temp.x
> 			&&(frame_s.frame_rect[k].x+frame_s.frame_rect[k].width)<=(temp.x+temp.width))//&& frame_s.frame_rect.size()==1
> 			{
> 				frame_s.is_body_down = true;
> 				fprintf(stderr,"teacher is down!\n");
> 				break;
> 			}	
> 		}	
> 		bool no_rect = false;
> 		//å…¨å±€éƒ½æ²¡æœ‰çŸ©å½¢æ¡†;
> 		if(frame_s.frame_rect.size()<=0) 
> 			no_rect = true;
> 		else//ç»™å®šçš„çŸ©å½¢æ¡†å†…æ²¡æœ‰mogçŸ©å½¢;
> 		{
> 			bool flag = true;
> 			for(int i = 0;i<frame_s.frame_rect.size();i++)
> 			{
> 				Rect m_r = frame_s.frame_rect[i];
> 				if( (m_r.x+m_r.width)<(temp.x) || m_r.x>(temp.x+temp.width)
> 					|| (m_r.y+m_r.height)<(temp.y) || m_r.y>(temp.y+temp.height))
> 				{continue;}
> 				else
> 				{
> 					flag = false;break;
> 				}
> 			}
> 			if(flag)
> 			{no_rect = true;}
> 		}
> 		if( no_rect && frame_s.is_body_down)
> 		{	
> 			if(!fillbg_struct.mog2_s.flag)
> 			{
> 				fillbg_struct.mog2_s.cur_time = fillbg_struct.mog2_s.pre_time = clock();
> 				fillbg_struct.mog2_s.flag = true;
> 			}
> 			else
> 			{
> 				fillbg_struct.mog2_s.cur_time = clock();
> 			}
> 		}	
> 		else
> 		{
> 			fillbg_struct.mog2_s.cur_time = fillbg_struct.mog2_s.pre_time = clock();
> 			frame_s.is_body_down = false;
> 			fillbg_struct.mog2_s.flag = false;
> 		}
> 		double interval_t =((double)(fillbg_struct.mog2_s.cur_time - fillbg_struct.mog2_s.pre_time) / CLOCKS_PER_SEC);
> 
> 		if(atoi(cfg_->get_value("debug","0"))>0)
> 		{
> 			if(interval_t>0)
> 		    {fprintf(stderr,"teacher_down_time = %f\n",interval_t);}
> 		}	
> 		//æ›´æ–°è“æ¡†åŒºåŸŸèƒŒæ™¯;
> 		if(interval_t>fillbg_struct.mog2_s.continued_time)
> 		{
> 			fillbg_struct.mog2_s.cur_time = fillbg_struct.mog2_s.pre_time = clock();
> 			updatebg(img2,fillbg_struct.fist_fillrect[0]);
> 			//è¿™ä¸ªåœ°æ–¹æœ‰å¾…æ”¹è¿›ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼ˆä¸èƒ½ç›´æ¥å°±è¿™ä¹ˆç®—äº†ï¼‰;
> 			fillbg_struct.nframe = 3;
> 			fillbg_struct.isfillok = true;
> 			//fillbg_struct.fist_fillrect.clear();
728,729c728,729
<             frame_s.is_body_down = false;
<         }
---
> 			frame_s.is_body_down = false;
> 		}
735,741c735,741
< //  buffer = (IplImage**)malloc(sizeof(buffer[0])*N);
< //  //buffer = new IplImage*[N];
< //  for(int i = 0;i<N;i++)
< //  {
< //      buffer[i]= cvCreateImage(cvSize(image->width,image->height),IPL_DEPTH_8U,1);
< //      cvSetZero(buffer[i]);
< //  }
---
> //	buffer = (IplImage**)malloc(sizeof(buffer[0])*N);
> //	//buffer = new IplImage*[N];
> //	for(int i = 0;i<N;i++)
> //	{
> //		buffer[i]= cvCreateImage(cvSize(image->width,image->height),IPL_DEPTH_8U,1);
> //		cvSetZero(buffer[i]);
> //	}
750,767c750,765
<     if(frame_s.buffer[0].empty())
<     {
<         for(int i = 0;i<(frame_s.N);i++)
<         {
<             cvtColor(img,frame_s.buffer[i],CV_BGR2GRAY);
<         }
<     }
<     cvtColor(img,frame_s.buffer[1],CV_BGR2GRAY);
<     absdiff(frame_s.buffer[1],frame_s.buffer[0],silh);
<     threshold( silh, silh, frame_s.threshold_two, 255, CV_THRESH_BINARY );
<     //cvSmooth((CvArr*)&silh,(CvArr*)&silh,CV_MEDIAN,3,0,0,0);
<     //cvSmooth((IplImage*)&silh,(IplImage*)&silh,CV_MEDIAN,3,0,0,0);
<     medianBlur(silh, silh, 3);
<     for(int i = 0;i<frame_s.N-1;i++)
<     {
<         frame_s.buffer[i] = frame_s.buffer[i+1].clone();
<     }
< 
---
> 	if(frame_s.buffer[0].empty())
> 	{
> 		for(int i = 0;i<(frame_s.N);i++)
> 		{
> 			cvtColor(img,frame_s.buffer[i],CV_BGR2GRAY);
> 		}	
> 	}	
> 	cvtColor(img,frame_s.buffer[1],CV_BGR2GRAY);
> 	absdiff(frame_s.buffer[1],frame_s.buffer[0],silh);
> 	threshold( silh, silh, frame_s.threshold_two, 255, CV_THRESH_BINARY );
> 	cvSmooth(&(IplImage)silh,&(IplImage)silh,CV_MEDIAN,3,0,0,0);
> 	for(int i = 0;i<frame_s.N-1;i++)
> 	{
> 		frame_s.buffer[i] = frame_s.buffer[i+1].clone();
> 	}
> 	
774,801c772,795
<     Mat silh_one;silh_one.setTo(Scalar::all(0));
<     Mat silh_two;silh_two.setTo(Scalar::all(0));
<     if(frame_s.buffer[0].empty())
<     {
<         for(int i = 0;i<(frame_s.N+1);i++)
<         {
<             //frame_s.buffer[i].create(Size(video_width_,video_height_),CV_8UC1);
<             cvtColor(img,frame_s.buffer[i],CV_BGR2GRAY);
<         }
<     }
<     cvtColor(img,frame_s.buffer[2],CV_BGR2GRAY);
< 
<     absdiff(frame_s.buffer[1],frame_s.buffer[0],silh_one);
<     threshold( silh_one, silh_one, frame_s.threshold_three, 255, CV_THRESH_BINARY );
< 
<     absdiff(frame_s.buffer[2],frame_s.buffer[1],silh_two);
<     threshold( silh_two, silh_two, frame_s.threshold_three, 255, CV_THRESH_BINARY );
< 
<     //cvAnd((CvArr*)&silh_one,(CvArr*)&silh_two,(CvArr*)&silh);
<     bitwise_and(silh_one, silh_two, silh);
<     //cvAnd((IplImage*)&silh_one,(IplImage*)&silh_two,(IplImage*)&silh);
<     //cvSmooth((CvArr*)&silh,(CvArr*)&silh,CV_MEDIAN,3,0,0,0);
<     //cvSmooth((IplImage*)&silh,(IplImage*)&silh,CV_MEDIAN,3,0,0,0);
<     medianBlur(silh, silh, 3);
<     for(int i = 0;i<frame_s.N-1;i++)
<     {
<         frame_s.buffer[i] = frame_s.buffer[i+1].clone();
<     }
---
> 	Mat silh_one;silh_one.setTo(Scalar::all(0));
> 	Mat silh_two;silh_two.setTo(Scalar::all(0));
> 	if(frame_s.buffer[0].empty())
> 	{
> 		for(int i = 0;i<(frame_s.N+1);i++)
> 		{
> 			//frame_s.buffer[i].create(Size(video_width_,video_height_),CV_8UC1);
> 			cvtColor(img,frame_s.buffer[i],CV_BGR2GRAY);
> 		}	
> 	}	
> 	cvtColor(img,frame_s.buffer[2],CV_BGR2GRAY);
> 	
> 	absdiff(frame_s.buffer[1],frame_s.buffer[0],silh_one);
> 	threshold( silh_one, silh_one, frame_s.threshold_three, 255, CV_THRESH_BINARY );
> 
> 	absdiff(frame_s.buffer[2],frame_s.buffer[1],silh_two);
> 	threshold( silh_two, silh_two, frame_s.threshold_three, 255, CV_THRESH_BINARY );
> 
> 	cvAnd(&(IplImage)silh_one,&(IplImage)silh_two,&(IplImage)silh);
> 	cvSmooth(&(IplImage)silh,&(IplImage)silh,CV_MEDIAN,3,0,0,0);
> 	for(int i = 0;i<frame_s.N-1;i++)
> 	{
> 		frame_s.buffer[i] = frame_s.buffer[i+1].clone();
> 	}	
809,857c803,851
<     //å…¨å›¾åƒå¸§å·®æ³•;(ç›®çš„:åˆ¤æ–­æ•™å¸ˆæ˜¯å¦èµ°ä¸‹è®²å°åŒº);
<     frame_s.frame_rect.clear();
<     std::vector<Rect> rect_vector_t;
<     Mat silh;silh.create(Size(raw_image.cols,raw_image.rows),CV_8UC1);
<     /*if(fillbg_struct.isfillok_end)
<         frame_s.N = 3;
<     if(frame_s.N == 3)
<     three_frame_method(raw_image,silh);
<     else if(frame_s.N == 2)*/
<     two_frame_method(raw_image,silh);
<     if(!fillbg_struct.isfillok_end)
<     {
<         /*Rect mk = Rect(0,(masked_rect.y-3*fillbg_struct.body_width),
<             raw_image.cols,(raw_image.rows-(masked_rect.y-3*fillbg_struct.body_width)-frame_s.bottom_inter));*/
<         Rect mk = Rect(0,masked_rect.y,
<             raw_image.cols,(masked_rect.height+frame_s.bottom_inter));
<         mk &= Rect(0,0,raw_image.cols,raw_image.rows);
<         Mat image_mk = Mat(raw_image,mk);
<         Mat silh_mk = Mat(silh,mk);
<         Mat dst_mk;
<         rect_vector_t = refineSegments2(image_mk,silh_mk,dst_mk,frame_s.interval,frame_s.minarea,frame_s.minrect);
<         for(int i = 0;i<rect_vector_t.size();i++)
<         {
<             Rect t = rect_vector_t[i];
<             //if(t.width*t.height>(pow(fillbg_struct.body_width/3.0,2)))
<             if(t.width*t.height>frame_s.minrect)
<             {
<                 t = Rect(t.x+mk.x,t.y+mk.y,t.width,t.height);
<                 frame_rect.push_back(t);
<                 /*if(atoi(cfg_->get_value("debug","0"))>0)
<                 {
<                     rectangle(raw_image,Rect(t.x,t.y,t.width,t.height),Scalar(0,0,0),2);
<                 }*/
<             }
<         }
<     }
<     //------------------------------------------
<     //æ©ç éƒ¨åˆ†å¸§å·®;
<     frame_s.masked_frame_rect.clear();
<     std::vector<Rect> masked_rect_vector_t;
<     Mat image_mask = Mat(raw_image,masked_rect);
<     Mat silh_mask = Mat(silh,masked_rect);
<     Mat dst_masked;
<     masked_rect_vector_t = refineSegments2(image_mask,silh_mask,dst_masked,frame_s.interval,frame_s.minarea,frame_s.minrect);
<     for(int i = 0;i<masked_rect_vector_t.size();i++)
<     {
<         Rect t = masked_rect_vector_t[i];
<         masked_frame_rect.push_back(t);
<     }
---
> 	//å…¨å›¾åƒå¸§å·®æ³•;(ç›®çš„:åˆ¤æ–­æ•™å¸ˆæ˜¯å¦èµ°ä¸‹è®²å°åŒº);
> 	frame_s.frame_rect.clear();
> 	std::vector<Rect> rect_vector_t;
> 	Mat silh;silh.create(Size(raw_image.cols,raw_image.rows),CV_8UC1);
> 	/*if(fillbg_struct.isfillok_end)
> 		frame_s.N = 3;
> 	if(frame_s.N == 3)
> 	three_frame_method(raw_image,silh);
> 	else if(frame_s.N == 2)*/
> 	two_frame_method(raw_image,silh);
> 	if(!fillbg_struct.isfillok_end)
> 	{
> 		/*Rect mk = Rect(0,(masked_rect.y-3*fillbg_struct.body_width),
> 			raw_image.cols,(raw_image.rows-(masked_rect.y-3*fillbg_struct.body_width)-frame_s.bottom_inter));*/
> 		Rect mk = Rect(0,masked_rect.y,
> 			raw_image.cols,(masked_rect.height+frame_s.bottom_inter));
> 		mk &= Rect(0,0,raw_image.cols,raw_image.rows);
> 		Mat image_mk = Mat(raw_image,mk);
> 		Mat silh_mk = Mat(silh,mk);
> 		Mat dst_mk;
> 		rect_vector_t = refineSegments2(image_mk,silh_mk,dst_mk,frame_s.interval,frame_s.minarea,frame_s.minrect);
> 		for(int i = 0;i<rect_vector_t.size();i++)
> 		{
> 			Rect t = rect_vector_t[i];
> 			//if(t.width*t.height>(pow(fillbg_struct.body_width/3.0,2)))
> 			if(t.width*t.height>frame_s.minrect)
> 			{
> 				t = Rect(t.x+mk.x,t.y+mk.y,t.width,t.height);
> 				frame_rect.push_back(t);
> 				/*if(atoi(cfg_->get_value("debug","0"))>0)
> 				{
> 					rectangle(raw_image,Rect(t.x,t.y,t.width,t.height),Scalar(0,0,0),2);
> 				}*/
> 			}				
> 		}
> 	}
> 	//------------------------------------------
> 	//æ©ç éƒ¨åˆ†å¸§å·®;
> 	frame_s.masked_frame_rect.clear();
> 	std::vector<Rect> masked_rect_vector_t;
> 	Mat image_mask = Mat(raw_image,masked_rect);
> 	Mat silh_mask = Mat(silh,masked_rect);
> 	Mat dst_masked;
> 	masked_rect_vector_t = refineSegments2(image_mask,silh_mask,dst_masked,frame_s.interval,frame_s.minarea,frame_s.minrect);
> 	for(int i = 0;i<masked_rect_vector_t.size();i++)
> 	{
> 		Rect t = masked_rect_vector_t[i];
> 		masked_frame_rect.push_back(t);		
> 	}
864,870c858,864
<     Mat mask(img.rows, img.cols, CV_8UC3,
<                     Scalar(0, 0, 0));
<     Rect r_temp = r;
<     r_temp &= Rect(0, 0, img.cols, img.rows);
<     Mat specified(mask, r_temp);
<     specified.setTo(1);
<     img.copyTo(fillbg_struct.bg, mask);
---
> 	Mat mask(img.rows, img.cols, CV_8UC3,
> 					Scalar(0, 0, 0));
> 	Rect r_temp = r;
> 	r_temp &= Rect(0, 0, img.cols, img.rows);
> 	Mat specified(mask, r_temp);
> 	specified.setTo(1);
> 	img.copyTo(fillbg_struct.bg, mask);
876,881c870,875
<     region.has_frame_rect = false;
<     region.has_old_rect = false;
<     region.cur_tbg = 0;
<     region.flage_bg = false;
<     region.pre_tbg = 0;
<     region.continuetime_bg = 0.0;
---
> 	region.has_frame_rect = false;
> 	region.has_old_rect = false;
> 	region.cur_tbg = 0;
> 	region.flage_bg = false;
> 	region.pre_tbg = 0;
> 	region.continuetime_bg = 0.0;	
886,889c880,883
<     region.cur_static = 0;
<     region.flag_static = false;
<     region.pre_static = 0;
<     region.continuetime_static = 0.0;
---
> 	region.cur_static = 0;
> 	region.flag_static = false;
> 	region.pre_static = 0;
> 	region.continuetime_static = 0.0;
895,906c889,900
<     Rect r_temp = r;
<     r_temp &= Rect(0, 0, img.cols, img.rows);
<     Mat bg_t = fillbg_struct.bg.clone();
<     Mat img_t = img.clone();
<     Mat dst = Mat(Size(img.cols,img.rows),CV_8UC3);
<     double rate = 1 - learn_rate;
<     addWeighted(img_t,learn_rate,bg_t,rate,0,dst);
< 
<     Mat mask(img.rows, img.cols, CV_8UC3,Scalar(0, 0, 0));
<     Mat specified(mask, r_temp);
<     specified.setTo(1);
<     dst.copyTo(fillbg_struct.bg, mask);
---
> 	Rect r_temp = r;
> 	r_temp &= Rect(0, 0, img.cols, img.rows);
> 	Mat bg_t = fillbg_struct.bg.clone();
> 	Mat img_t = img.clone();
> 	Mat dst = Mat(Size(img.cols,img.rows),CV_8UC3);
> 	double rate = 1 - learn_rate;
> 	addWeighted(img_t,learn_rate,bg_t,rate,0,dst);
> 
> 	Mat mask(img.rows, img.cols, CV_8UC3,Scalar(0, 0, 0));
> 	Mat specified(mask, r_temp);
> 	specified.setTo(1);
> 	dst.copyTo(fillbg_struct.bg, mask);
912,923c906,917
<     Rect r_temp = r;
<     r_temp &= Rect(0, 0, img.cols, img.rows);
<     Mat bg_t = up_update.upbody_bg.clone();
<     Mat img_t = img.clone();
<     Mat dst = Mat(Size(img.cols,img.rows),CV_8UC3);
<     double rate = 1 - learn_rate;
<     addWeighted(img_t,learn_rate,bg_t,rate,0,dst);
< 
<     Mat mask(img.rows, img.cols, CV_8UC3,Scalar(0, 0, 0));
<     Mat specified(mask, r_temp);
<     specified.setTo(1);
<     dst.copyTo(up_update.upbody_bg, mask);
---
> 	Rect r_temp = r;	
> 	r_temp &= Rect(0, 0, img.cols, img.rows);
> 	Mat bg_t = up_update.upbody_bg.clone();
> 	Mat img_t = img.clone();
> 	Mat dst = Mat(Size(img.cols,img.rows),CV_8UC3);
> 	double rate = 1 - learn_rate;
> 	addWeighted(img_t,learn_rate,bg_t,rate,0,dst);
> 
> 	Mat mask(img.rows, img.cols, CV_8UC3,Scalar(0, 0, 0));
> 	Mat specified(mask, r_temp);
> 	specified.setTo(1);
> 	dst.copyTo(up_update.upbody_bg, mask);
929,1109c923,1103
<     //æ¯æ¬¡éƒ½è¦æ¸…ç©º;
<     for(int j = 0;j<ud_bg_s.region_num;j++)
<     {
<         ud_bg_s.region[j].has_old_rect = false;
<         ud_bg_s.region[j].has_frame_rect = false;
<     }
<     //************************************************************
<     //çº¢è‰²çŸ©å½¢æ¡†æ‰€å çš„åŒºåŸŸ;
<     std::vector<int> valid_oldrect;
<     for(int i = 0;i<fillbg_struct.rect_old.size();i++)
<     {
<         Rect t_old = Rect(fillbg_struct.rect_old[i].x-15,fillbg_struct.rect_old[i].y,
<             fillbg_struct.rect_old[i].width+30,fillbg_struct.rect_old[i].height);
<         t_old &= Rect(0,0,image.cols,image.rows);
<         fillbg_struct.rect_old[i] = t_old;//æ‰©å±•ä¸€ä¸‹çº¢æ¡†;
<         int left = t_old.x/ud_bg_s.region_interval;//è¿™ä¸ªåœ°æ–¹å¯ä»¥å†ç²¾ç¡®ä¸€ç‚¹;
<         int right = (t_old.x+t_old.width)/ud_bg_s.region_interval;
<         for(int j = 0;j<ud_bg_s.region_num;j++)
<         {
<             if(j >= left && j <= right)
<             {
<                 if(!ud_bg_s.region[j].has_old_rect)
<                 {
<                     ud_bg_s.region[j].has_old_rect = true;
<                     valid_oldrect.push_back(j);
<                 }
<             }
<         }
<     }
<     //************************************************************
<     //ä¸æ˜¯çº¢æ¡†é®ç›–åŒºçš„åŒºåŸŸéƒ½è¦æ¸…é›¶å¤„ç†;
<     for(int j = 0;j<ud_bg_s.region_num;j++)
<     {
<         bool f = false;
<         for(int i = 0;i<valid_oldrect.size();i++)
<         {
<             if(j == valid_oldrect[i])
<             {
<                 f= true;
<                 break;
<             }
<         }
<         if(!f)
<         {
<             reset_region(ud_bg_s.region[j]);
<         }
<     }
<     //************************************************************
<     //è¿™é‡Œè¦å»æ‰å¹²æ‰°çš„å¸§å·®(å³åœ¨çº¢æ¡†å¤–çš„å¸§å·®);
<     std::vector<Rect> masked_frame_rect_valid;
<     for(int k = 0;k<frame_s.masked_frame_rect.size();k++)
<     {
<         Rect t = frame_s.masked_frame_rect[k];
<         for(int i = 0;i<fillbg_struct.rect_old.size();i++)
<         {
<             Rect t_rectold = fillbg_struct.rect_old[i];
<             if(!(t.x >(t_rectold.x + t_rectold.width + 20)
<                || (t.x + t.width + 20) <t_rectold.x))
<             {
<                 if(t.width<fillbg_struct.body_width)
<                 {
<                     if((t.x-fillbg_struct.body_width/2)<t_rectold.x)
<                     {
<                         t = Rect(t_rectold.x,t.y,fillbg_struct.body_width*2,t.height);
<                         t &= t_rectold;
<                     }
<                     else if((t.x+t.width+fillbg_struct.body_width/2)>t_rectold.x+t_rectold.width)
<                     {
<                         t = Rect(t_rectold.x+t_rectold.width-fillbg_struct.body_width*2,
<                             t.y,fillbg_struct.body_width*2,t.height);
<                         t &= t_rectold;
<                     }
<                     else
<                     {
<                         t = Rect((t.x+t.width/2-fillbg_struct.body_width),t.y,fillbg_struct.body_width*2,t.height);
<                         t &= t_rectold;
<                     }
<                 }
<                 else
<                 {
<                     t = Rect((t.x-10),t.y,t.width+20,t.height);
<                 }
<                 t &= Rect(0,0,raw_img.cols,raw_img.rows);
<                 masked_frame_rect_valid.push_back(t);
<                 break;
<             }
<         }
<     }
<     /*if(atoi(cfg_->get_value("debug","0"))>0)
<     {
<         for(int k = 0;k<masked_frame_rect_valid.size();k++)
<         {
<             Rect t = masked_frame_rect_valid[k];
<             rectangle(raw_img,Rect(t.x+masked_rect.x,t.y+masked_rect.y,t.width,t.height),Scalar(0,255,0),2);
<         }
<     }*/
<     //************************************************************
<     //è·å–å¸§å·®çŸ©å½¢æ‰€å çš„åŒºåŸŸ;
<     std::vector<int> valid_framerect;
<     for(int k = 0;k<masked_frame_rect_valid.size();k++)
<     {
<         Rect t = masked_frame_rect_valid[k];
<         int left = t.x/ud_bg_s.region_interval;//è¿™ä¸ªåœ°æ–¹å¯ä»¥å†ç²¾ç¡®ä¸€ç‚¹;
<         int right = (t.x+t.width)/ud_bg_s.region_interval;
<         for(int j = 0;j<ud_bg_s.region_num;j++)
<         {
<             if(j >= left && j <= right)
<             {
<                 if(!ud_bg_s.region[j].has_frame_rect)
<                 {
<                     ud_bg_s.region[j].has_frame_rect = true;
<                     valid_framerect.push_back(j);
<                 }
<             }
<         }
<     }
<     //************************************************************
<     //æ²¡æœ‰å¸§å·®æ¡†æ—¶é™¤çº¢æ¡†å¤–çš„åŒºåŸŸéƒ½ç¼“æ…¢çš„è¿›è¡Œæ›´æ–°;
<     if(valid_framerect.size()<1)
<     {
<         for(int j = 0;j<ud_bg_s.region_num;j++)
<         {
<             if(!ud_bg_s.region[j].has_old_rect)
<             {
<                 updatebg_slow(image,ud_bg_s.region[j].region,ud_bg_s.slow_learn_rate);
<             }
<         }
<     }
<     //************************************************************
<     //æœ‰å¸§å·®ä¸”èƒŒæ™¯æœªå½»åº•æ›´æ–°å®Œæˆä¹‹å‰æ—¶ï¼ŒåŒæ—¶æœ‰å¸§å·®å’Œçº¢æ¡†å¤–çš„åŒºåŸŸè¿›è¡Œè¾ƒå¿«çš„æ›´æ–°;
<     if(valid_framerect.size()>0 && !fillbg_struct.isfillok_end)
<     {
<         bool flag_t = false;
<         for(int j = 0;j<ud_bg_s.region_num;j++)
<         {
<             if(ud_bg_s.region[j].has_frame_rect && ud_bg_s.region[j].has_old_rect )
<             {
<                 flag_t = true;
<                 break;
<             }
<         }
<         if(flag_t)
<         {
<             for(int j = 0;j<ud_bg_s.region_num;j++)
<             {
<                 if(!(ud_bg_s.region[j].has_frame_rect && ud_bg_s.region[j].has_old_rect))
<                 {
<                     updatebg_slow(image,ud_bg_s.region[j].region,ud_bg_s.fast_learn_rate);
<                     //åˆ¤æ–­ç›®æ ‡æ˜¯å¦ä»åˆå§‹ä½ç½®ç§»åŠ¨äº†ä¸€æ®µè·ç¦»;
<                     if(fillbg_struct.fist_fillrect.size()>0 && !fillbg_struct.body_move)
<                     {
<                         Rect t_t = fillbg_struct.fist_fillrect[0];
<                         if(t_t.x+t_t.width/2 >= ud_bg_s.region[j].region.x &&
<                             t_t.x+t_t.width/2 <= (ud_bg_s.region[j].region.x+ud_bg_s.region[j].region.width))
<                         {
<                             fillbg_struct.body_move = true;
<                         }
<                     }
<                 }
<             }
<         }
<     }
<     //************************************************************
<     std::vector<int> valid_both;//åŒæ—¶æœ‰å¸§å·®å’Œçº¢æ¡†çš„åŒºåŸŸ;
<     std::vector<int> valid_one;//åªæœ‰çº¢æ¡†æ²¡å¸§å·®çš„åŒºåŸŸ;
<     for(int i = 0;i<valid_oldrect.size();i++)
<     {
<         int region_num = valid_oldrect[i];
<         bool flag_t = false;
<         for( int j = 0;j<valid_framerect.size();j++)
<         {
<             if( valid_framerect[j] == valid_oldrect[i])
<             {
<                 valid_both.push_back(valid_oldrect[i]);
<                 flag_t = true;
<                 break;
<             }
<         }
<         if(flag_t)
<         {
<             reset_region(ud_bg_s.region[region_num]);
---
> 	//æ¯æ¬¡éƒ½è¦æ¸…ç©º;
> 	for(int j = 0;j<ud_bg_s.region_num;j++)
> 	{
> 		ud_bg_s.region[j].has_old_rect = false;
> 		ud_bg_s.region[j].has_frame_rect = false;
> 	}
> 	//************************************************************
> 	//çº¢è‰²çŸ©å½¢æ¡†æ‰€å çš„åŒºåŸŸ;
> 	std::vector<int> valid_oldrect;
> 	for(int i = 0;i<fillbg_struct.rect_old.size();i++)
> 	{
> 		Rect t_old = Rect(fillbg_struct.rect_old[i].x-15,fillbg_struct.rect_old[i].y,
> 			fillbg_struct.rect_old[i].width+30,fillbg_struct.rect_old[i].height);
> 		t_old &= Rect(0,0,image.cols,image.rows);
> 		fillbg_struct.rect_old[i] = t_old;//æ‰©å±•ä¸€ä¸‹çº¢æ¡†;
> 		int left = t_old.x/ud_bg_s.region_interval;//è¿™ä¸ªåœ°æ–¹å¯ä»¥å†ç²¾ç¡®ä¸€ç‚¹;
> 		int right = (t_old.x+t_old.width)/ud_bg_s.region_interval;
> 		for(int j = 0;j<ud_bg_s.region_num;j++)
> 		{
> 			if(j >= left && j <= right)
> 			{
> 				if(!ud_bg_s.region[j].has_old_rect)
> 				{
> 					ud_bg_s.region[j].has_old_rect = true;
> 					valid_oldrect.push_back(j);
> 				}		
> 			}
> 		}
> 	}
> 	//************************************************************
> 	//ä¸æ˜¯çº¢æ¡†é®ç›–åŒºçš„åŒºåŸŸéƒ½è¦æ¸…é›¶å¤„ç†;
> 	for(int j = 0;j<ud_bg_s.region_num;j++)
> 	{
> 		bool f = false;
> 		for(int i = 0;i<valid_oldrect.size();i++)
> 		{
> 			if(j == valid_oldrect[i])
> 			{		
> 				f= true;
> 				break;
> 			}
> 		}
> 		if(!f)
> 		{
> 			reset_region(ud_bg_s.region[j]);
> 		}
> 	}
> 	//************************************************************
> 	//è¿™é‡Œè¦å»æ‰å¹²æ‰°çš„å¸§å·®(å³åœ¨çº¢æ¡†å¤–çš„å¸§å·®);
> 	std::vector<Rect> masked_frame_rect_valid;
> 	for(int k = 0;k<frame_s.masked_frame_rect.size();k++)
> 	{
> 		Rect t = frame_s.masked_frame_rect[k];
> 		for(int i = 0;i<fillbg_struct.rect_old.size();i++)
> 		{
> 			Rect t_rectold = fillbg_struct.rect_old[i];
> 			if(!(t.x >(t_rectold.x + t_rectold.width + 20)
> 		       || (t.x + t.width + 20) <t_rectold.x))
> 			{
> 				if(t.width<fillbg_struct.body_width)
> 				{
> 					if((t.x-fillbg_struct.body_width/2)<t_rectold.x)
> 					{
> 						t = Rect(t_rectold.x,t.y,fillbg_struct.body_width*2,t.height);
> 						t &= t_rectold;
> 					}
> 					else if((t.x+t.width+fillbg_struct.body_width/2)>t_rectold.x+t_rectold.width)
> 					{
> 						t = Rect(t_rectold.x+t_rectold.width-fillbg_struct.body_width*2,
> 							t.y,fillbg_struct.body_width*2,t.height);
> 						t &= t_rectold;
> 					}
> 					else
> 					{
> 						t = Rect((t.x+t.width/2-fillbg_struct.body_width),t.y,fillbg_struct.body_width*2,t.height);	  
> 						t &= t_rectold;
> 					}	
> 				}
> 				else
> 				{
> 					t = Rect((t.x-10),t.y,t.width+20,t.height);
> 				}
> 				t &= Rect(0,0,raw_img.cols,raw_img.rows);
> 				masked_frame_rect_valid.push_back(t);
> 				break;
> 			}
> 		}		
> 	}
> 	/*if(atoi(cfg_->get_value("debug","0"))>0)
> 	{
> 		for(int k = 0;k<masked_frame_rect_valid.size();k++)
> 		{
> 			Rect t = masked_frame_rect_valid[k];
> 			rectangle(raw_img,Rect(t.x+masked_rect.x,t.y+masked_rect.y,t.width,t.height),Scalar(0,255,0),2);	
> 		}
> 	}*/
> 	//************************************************************
> 	//è·å–å¸§å·®çŸ©å½¢æ‰€å çš„åŒºåŸŸ;
> 	std::vector<int> valid_framerect;
> 	for(int k = 0;k<masked_frame_rect_valid.size();k++)
> 	{
> 		Rect t = masked_frame_rect_valid[k];
> 		int left = t.x/ud_bg_s.region_interval;//è¿™ä¸ªåœ°æ–¹å¯ä»¥å†ç²¾ç¡®ä¸€ç‚¹;
> 		int right = (t.x+t.width)/ud_bg_s.region_interval;
> 		for(int j = 0;j<ud_bg_s.region_num;j++)
> 		{
> 			if(j >= left && j <= right)
> 			{
> 				if(!ud_bg_s.region[j].has_frame_rect)
> 				{
> 					ud_bg_s.region[j].has_frame_rect = true;
> 					valid_framerect.push_back(j);
> 				}		
> 			}
> 		}
> 	}
> 	//************************************************************
> 	//æ²¡æœ‰å¸§å·®æ¡†æ—¶é™¤çº¢æ¡†å¤–çš„åŒºåŸŸéƒ½ç¼“æ…¢çš„è¿›è¡Œæ›´æ–°;
> 	if(valid_framerect.size()<1)
> 	{
> 		for(int j = 0;j<ud_bg_s.region_num;j++)
> 		{
> 			if(!ud_bg_s.region[j].has_old_rect)
> 			{
> 				updatebg_slow(image,ud_bg_s.region[j].region,ud_bg_s.slow_learn_rate);
> 			}
> 		}
> 	}
> 	//************************************************************
> 	//æœ‰å¸§å·®ä¸”èƒŒæ™¯æœªå½»åº•æ›´æ–°å®Œæˆä¹‹å‰æ—¶ï¼ŒåŒæ—¶æœ‰å¸§å·®å’Œçº¢æ¡†å¤–çš„åŒºåŸŸè¿›è¡Œè¾ƒå¿«çš„æ›´æ–°;
> 	if(valid_framerect.size()>0 && !fillbg_struct.isfillok_end)
> 	{
> 		bool flag_t = false;
> 		for(int j = 0;j<ud_bg_s.region_num;j++)
> 		{		
> 			if(ud_bg_s.region[j].has_frame_rect && ud_bg_s.region[j].has_old_rect )
> 			{
> 				flag_t = true;
> 				break;
> 			}		
> 		}
> 		if(flag_t)
> 		{
> 			for(int j = 0;j<ud_bg_s.region_num;j++)
> 			{	
> 				if(!(ud_bg_s.region[j].has_frame_rect && ud_bg_s.region[j].has_old_rect))
> 				{
> 					updatebg_slow(image,ud_bg_s.region[j].region,ud_bg_s.fast_learn_rate);
> 					//åˆ¤æ–­ç›®æ ‡æ˜¯å¦ä»åˆå§‹ä½ç½®ç§»åŠ¨äº†ä¸€æ®µè·ç¦»;
> 					if(fillbg_struct.fist_fillrect.size()>0 && !fillbg_struct.body_move)
> 					{
> 						Rect t_t = fillbg_struct.fist_fillrect[0];
> 						if(t_t.x+t_t.width/2 >= ud_bg_s.region[j].region.x &&
> 							t_t.x+t_t.width/2 <= (ud_bg_s.region[j].region.x+ud_bg_s.region[j].region.width))
> 						{
> 							fillbg_struct.body_move = true;
> 						}
> 					}
> 				}
> 			}
> 		}		
> 	}
> 	//************************************************************
> 	std::vector<int> valid_both;//åŒæ—¶æœ‰å¸§å·®å’Œçº¢æ¡†çš„åŒºåŸŸ;
> 	std::vector<int> valid_one;//åªæœ‰çº¢æ¡†æ²¡å¸§å·®çš„åŒºåŸŸ;
> 	for(int i = 0;i<valid_oldrect.size();i++)
> 	{
> 		int region_num = valid_oldrect[i];
> 		bool flag_t = false;
> 		for( int j = 0;j<valid_framerect.size();j++)
> 		{
> 			if( valid_framerect[j] == valid_oldrect[i])
> 			{
> 				valid_both.push_back(valid_oldrect[i]);
> 			    flag_t = true;
> 				break;
> 			}		
> 		}
> 		if(flag_t)
> 		{
> 			reset_region(ud_bg_s.region[region_num]);
1111,1181c1105,1175
<         }
<         if(!flag_t)
<         {
<             valid_one.push_back(valid_oldrect[i]);
<             ud_bg_s.region[region_num].has_frame_rect = false;
<             if(!ud_bg_s.region[region_num].flage_bg)
<             {
<                 ud_bg_s.region[region_num].cur_tbg = ud_bg_s.region[region_num].pre_tbg = clock();
<                 ud_bg_s.region[region_num].flage_bg = true;
<             }
<             else
<             {
<                 ud_bg_s.region[region_num].cur_tbg = clock();
<                 ud_bg_s.region[region_num].continuetime_bg =
<                     double(ud_bg_s.region[region_num].cur_tbg - ud_bg_s.region[region_num].pre_tbg)/CLOCKS_PER_SEC;
< 
<                 if(ud_bg_s.region[region_num].continuetime_bg > ud_bg_s.time)
<                 {
<                     //å¤§äºä¸€åˆ†é’Ÿç›´æ¥æ›´æ–°;
<                     updatebg(image,ud_bg_s.region[region_num].region);
<                     reset_region(ud_bg_s.region[region_num]);
<                 }
<             }
<         }
<     }
<     //************************************************************
<     //å¸§å·®åŒºå¤–çš„æœ‰æ•ˆåŒºåŸŸ10ç§’æ— å¸§å·®è®¤ä¸ºæ˜¯é™æ­¢çš„ç›®æ ‡ï¼Œç»™äºˆå¿«é€Ÿæ›´æ–°;
<     for(int i = 0;i<ud_bg_s.region_num;i++)
<     {
<         bool flag = false;
<         for(int j = 0;j<valid_one.size();j++)
<         {
<             if(i == valid_one[j])
<             {
<                 flag = true;
<                 break;
<             }
<         }
<         if(!flag)
<         {
<             reset_static_region(ud_bg_s.region[i]);
<         }
<     }
<     for(int i = 0;i<valid_one.size();i++)
<     {
<         if(ud_bg_s.region[valid_one[i]].flag_static)
<         {
<             ud_bg_s.region[valid_one[i]].cur_static = clock();
<             ud_bg_s.region[valid_one[i]].continuetime_static =
<             double(ud_bg_s.region[valid_one[i]].cur_static - ud_bg_s.region[valid_one[i]].pre_static)/CLOCKS_PER_SEC;
<             if(ud_bg_s.region[valid_one[i]].continuetime_static > ud_bg_s.multiple_target_time)
<             {
<                 //å¤§äº10så¼€å§‹æ›´æ–°;
<                 if(valid_oldrect.size()>1)
<                 {
<                     updatebg(image,ud_bg_s.region[valid_one[i]].region);
<                     reset_static_region(ud_bg_s.region[valid_one[i]]);
<                     reset_region(ud_bg_s.region[valid_one[i]]);
<                 }
<             }
<         }
<         else if(valid_both.size()> 0 && !ud_bg_s.region[valid_one[i]].flag_static)
<         {
<             ud_bg_s.region[valid_one[i]].cur_static = ud_bg_s.region[valid_one[i]].pre_static = clock();
<             ud_bg_s.region[valid_one[i]].flag_static = true;
<         }
<         else
<         {
<             reset_static_region(ud_bg_s.region[valid_one[i]]);
<         }
<     }
---
> 		}
> 		if(!flag_t)
> 		{
> 			valid_one.push_back(valid_oldrect[i]);
> 			ud_bg_s.region[region_num].has_frame_rect = false;
> 			if(!ud_bg_s.region[region_num].flage_bg) 
> 			{
> 				ud_bg_s.region[region_num].cur_tbg = ud_bg_s.region[region_num].pre_tbg = clock();
> 				ud_bg_s.region[region_num].flage_bg = true;
> 			}
> 			else
> 			{
> 				ud_bg_s.region[region_num].cur_tbg = clock();
> 				ud_bg_s.region[region_num].continuetime_bg = 
> 					double(ud_bg_s.region[region_num].cur_tbg - ud_bg_s.region[region_num].pre_tbg)/CLOCKS_PER_SEC;
> 							
> 				if(ud_bg_s.region[region_num].continuetime_bg > ud_bg_s.time)
> 				{
> 					//å¤§äºä¸€åˆ†é’Ÿç›´æ¥æ›´æ–°;
> 					updatebg(image,ud_bg_s.region[region_num].region);
> 					reset_region(ud_bg_s.region[region_num]);
> 				}
> 			}
> 		}
> 	}
> 	//************************************************************
> 	//å¸§å·®åŒºå¤–çš„æœ‰æ•ˆåŒºåŸŸ10ç§’æ— å¸§å·®è®¤ä¸ºæ˜¯é™æ­¢çš„ç›®æ ‡ï¼Œç»™äºˆå¿«é€Ÿæ›´æ–°;
> 	for(int i = 0;i<ud_bg_s.region_num;i++)
> 	{
> 		bool flag = false;
> 		for(int j = 0;j<valid_one.size();j++)
> 		{
> 			if(i == valid_one[j])
> 			{
> 				flag = true;
> 				break;
> 			}
> 		}
> 		if(!flag)
> 		{
> 			reset_static_region(ud_bg_s.region[i]);
> 		}
> 	}
> 	for(int i = 0;i<valid_one.size();i++)
> 	{
> 		if(ud_bg_s.region[valid_one[i]].flag_static)
> 		{
> 			ud_bg_s.region[valid_one[i]].cur_static = clock();
> 			ud_bg_s.region[valid_one[i]].continuetime_static = 
> 			double(ud_bg_s.region[valid_one[i]].cur_static - ud_bg_s.region[valid_one[i]].pre_static)/CLOCKS_PER_SEC;							
> 			if(ud_bg_s.region[valid_one[i]].continuetime_static > ud_bg_s.multiple_target_time)
> 			{
> 				//å¤§äº10så¼€å§‹æ›´æ–°;
> 				if(valid_oldrect.size()>1)
> 				{
> 					updatebg(image,ud_bg_s.region[valid_one[i]].region);
> 				    reset_static_region(ud_bg_s.region[valid_one[i]]);
> 				    reset_region(ud_bg_s.region[valid_one[i]]);
> 				}
> 			}
> 		}
> 		else if(valid_both.size()> 0 && !ud_bg_s.region[valid_one[i]].flag_static)
> 		{
> 			ud_bg_s.region[valid_one[i]].cur_static = ud_bg_s.region[valid_one[i]].pre_static = clock();
> 			ud_bg_s.region[valid_one[i]].flag_static = true;
> 		}
> 		else
> 		{
> 			reset_static_region(ud_bg_s.region[valid_one[i]]);
> 		}
> 	}		
1187,1206c1181,1200
<     // æ ¹æ®çº¢æ¡†æ›´æ–°èº«é«˜æ¢æµ‹åŒºçš„èƒŒæ™¯ ...
<     if(fillbg_struct.nframe >= 2 && fillbg_struct.rect_old.size() == 1)
<     {
<         Rect t = Rect(fillbg_struct.rect_old[0].x + masked_rect.x, fillbg_struct.rect_old[0].y + masked_rect.y,
<                            fillbg_struct.rect_old[0].width, fillbg_struct.rect_old[0].height);
<         t &= Rect(0, 0, video_width_, video_height_);
< 
<         if(t.x > upbody_masked_rect.x && t.x < upbody_masked_rect.x + upbody_masked_rect.width)
<         {
<             Rect temp = Rect(0, 0, (t.x - upbody_masked_rect.x), upbody_masked_rect.height);
<             upbody_updatebg_slow(upbody_img, temp, 0.7);
<             //rectangle(upbody_img, temp, Scalar(0, 0, 255), 2);
<         }
<         if((t.x + t.width) < upbody_masked_rect.x + upbody_masked_rect.width && (t.x + t.width) > upbody_masked_rect.x)
<         {
<             Rect temp = Rect( t.x + t.width - upbody_masked_rect.x, 0, ((upbody_masked_rect.x + upbody_masked_rect.width) -
<                               (t.x + t.width)), upbody_masked_rect.height);
<             upbody_updatebg_slow(upbody_img, temp, 0.7);
<             //rectangle(upbody_img, temp, Scalar(255, 0, 255), 2);
<         }
---
> 	// æ ¹æ®çº¢æ¡†æ›´æ–°èº«é«˜æ¢æµ‹åŒºçš„èƒŒæ™¯ ...
> 	if(fillbg_struct.nframe >= 2 && fillbg_struct.rect_old.size() == 1)
> 	{
> 		Rect t = Rect(fillbg_struct.rect_old[0].x + masked_rect.x, fillbg_struct.rect_old[0].y + masked_rect.y, 
> 			               fillbg_struct.rect_old[0].width, fillbg_struct.rect_old[0].height);
> 		t &= Rect(0, 0, video_width_, video_height_);
> 
> 		if(t.x > upbody_masked_rect.x && t.x < upbody_masked_rect.x + upbody_masked_rect.width)
> 		{
> 			Rect temp = Rect(0, 0, (t.x - upbody_masked_rect.x), upbody_masked_rect.height);
> 			upbody_updatebg_slow(upbody_img, temp, 0.7);
> 			//rectangle(upbody_img, temp, Scalar(0, 0, 255), 2);
> 		}
> 		if((t.x + t.width) < upbody_masked_rect.x + upbody_masked_rect.width && (t.x + t.width) > upbody_masked_rect.x)
> 		{
> 			Rect temp = Rect( t.x + t.width - upbody_masked_rect.x, 0, ((upbody_masked_rect.x + upbody_masked_rect.width) - 
> 				              (t.x + t.width)), upbody_masked_rect.height);
> 			upbody_updatebg_slow(upbody_img, temp, 0.7);
> 			//rectangle(upbody_img, temp, Scalar(255, 0, 255), 2);			
> 		}
1212,1232c1206,1226
<     if(up_update.upbody_bg.empty())
<     {
<         up_update.frame_num++;
<         if( up_update.frame_num == 10)
<         {
<             img_upbody.copyTo(up_update.upbody_bg);
<         }
<     }
<     if(!up_update.upbody_bg.empty())
<     {
<         upbody_luv_method(img_upbody);
<         upbody_bgupdate(img_upbody);
<     }
<     if (atoi(cfg_->get_value("debug", "0")) > 0)
<     {
<         if (!up_update.upbody_bg.empty())
<         {
<             imshow("bg_upbody", up_update.upbody_bg);
<             waitKey(1);
<         }
<     }
---
> 	if(up_update.upbody_bg.empty())
> 	{
> 		up_update.frame_num++;
> 		if( up_update.frame_num == 10)
> 		{
> 			img_upbody.copyTo(up_update.upbody_bg);
> 		}
> 	}	
> 	if(!up_update.upbody_bg.empty())
> 	{
> 		upbody_luv_method(img_upbody);
> 		upbody_bgupdate(img_upbody);		   
> 	}
> 	if (atoi(cfg_->get_value("debug", "0")) > 0)
> 	{
> 		if (!up_update.upbody_bg.empty()) 
> 		{
> 			imshow("bg_upbody", up_update.upbody_bg);
> 			waitKey(1);
> 		}
> 	}
1237c1231
<                  vector < Rect > &first_rect)
---
> 				 vector < Rect > &first_rect)
1239,1281c1233,1234
<     fillbg_struct.num++;
<     bool has_rect = false;
< 
<     /*Mat bgmask;
<     Mat Img(img_);
<     Mat img = Img.clone();*/
< 
<     //åˆå§‹èƒŒæ™¯;
<     if (fillbg_struct.num == 10) {
<         //fillbg_struct.bg = img;
<          img.copyTo(fillbg_struct.bg);
<     }
<     //è·å¾—èƒŒæ™¯å‡é™¤æ³•çŸ©å½¢æ¡†;fillbg_struct.rect_old;
<     if (!fillbg_struct.bg.empty())
<     {
<         luv_method(img);
<     }
< 
<     //åŸå§‹å›¾åƒå¸§å·®æ³•;
<     frame_difference_method(raw_img,frame_s.frame_rect,frame_s.masked_frame_rect);
< 
<     //åˆ¤å®šäººæ˜¯å¦èµ°ä¸‹è®²å°åŒº;
<     if(fillbg_struct.nframe >1 && !fillbg_struct.isfillok_end)
<     {
<         is_teacher_down(raw_img,img);
<     }
< 
<     //å¸§å·®æ³•åŠ¨æ€æ›´æ–°èƒŒæ™¯;
<     if(fillbg_struct.nframe >1)
<     {
<         frame_updatebg(raw_img,img);
<     }
< 
<     //å¼€å§‹æ—¶æ²¡ç›®æ ‡æ—¶ç”¨ç¬¬ä¸€æ¬¡çš„(é˜²æ­¢å¼€å§‹äººä¸åŠ¨ä¸¢ç›®æ ‡) ;
<     if (!fillbg_struct.isfillok && fillbg_struct.rect_old.size() <= 0
<         &&fillbg_struct.nframe == 2 && !frame_s.is_body_down && !fillbg_struct.body_move)
<     {
<         Rect t = fillbg_struct.fist_fillrect[0];
<         Rect r = Rect(t.x+t.width/2-fillbg_struct.body_width,t.y+t.height/2-fillbg_struct.body_width,
<                        2*fillbg_struct.body_width,2*fillbg_struct.body_width);
<         r &= Rect(0,0,img.cols,img.rows);
<         fillbg_struct.rect_old.push_back(r);
<     }
---
> 	fillbg_struct.num++;
> 	bool has_rect = false;
1283,1315c1236,1309
<     //åˆ¤æ–­æ˜¯å¦æ˜¯é”™è¯¯çš„æ›´æ–°;
<     is_need_fillbg_twice(img);
< 
<     //LUVç®—æ³•ï¼Œåˆå§‹æ›´æ–°å®Œä¹‹åï¼Œæ ¹æ®å¾—åˆ°å¾—rectå’Œå®æ—¶çš„å›¾åƒä»¥åŠbgå›¾åƒï¼Œæ›´æ–°bgå›¾;
<     if (!fillbg_struct.isfillok)
<     {
<         fillbg_LUV(img);
<     }
< 
<     //å¦‚æœåŠåˆ†é’Ÿå†…ä¸€ä¸ªç›®æ ‡ä¹Ÿæ²¡æœ‰ï¼Œåˆ™æ›´æ–°æ•´ä¸ªèƒŒæ™¯åŒº;
<     //norect_update_bg(img);
< 
<     //è°ƒè¯•é€‰é¡¹;
<     if (atoi(cfg_->get_value("debug", "0")) > 0)
<     {
<         if (!fillbg_struct.bg.empty())
<         {
<             imshow("bg", fillbg_struct.bg);
<             waitKey(1);
<         }
<     }
<     //ä¸¤ä¸ªç›®æ ‡ç›¸è·ä¸€å®šè·ç¦»æ—¶è¿›è¡Œèåˆ;(å‰é¢èåˆçš„å¤§æ¦‚æ˜¯ä¸€ä¸ªç›®æ ‡çš„è·ç¦»);
<     rect_fusion2( fillbg_struct.rect_old,fillbg_struct.mog2_interval1);
<     if(!fillbg_struct.isfillok)
<     {
<         first_rect = fillbg_struct.fist_fillrect;
<     }
<     r = fillbg_struct.rect_old;
<     if (fillbg_struct.rect_old.size() > 0)
<     {
<         has_rect = true;
<     }
<     return has_rect;
---
> 	/*Mat bgmask;
> 	Mat Img(img_);
> 	Mat img = Img.clone();*/
> 
> 	//åˆå§‹èƒŒæ™¯;
> 	if (fillbg_struct.num == 10) {
> 		//fillbg_struct.bg = img;
> 		 img.copyTo(fillbg_struct.bg);
> 	}
> 	//è·å¾—èƒŒæ™¯å‡é™¤æ³•çŸ©å½¢æ¡†;fillbg_struct.rect_old;
> 	if (!fillbg_struct.bg.empty()) 
> 	{
> 		luv_method(img);
> 	}
> 	
> 	//åŸå§‹å›¾åƒå¸§å·®æ³•;
> 	frame_difference_method(raw_img,frame_s.frame_rect,frame_s.masked_frame_rect);
> 	 
> 	//åˆ¤å®šäººæ˜¯å¦èµ°ä¸‹è®²å°åŒº;
> 	if(fillbg_struct.nframe >1 && !fillbg_struct.isfillok_end)
> 	{
> 		is_teacher_down(raw_img,img);
> 	}
> 
> 	//å¸§å·®æ³•åŠ¨æ€æ›´æ–°èƒŒæ™¯;
> 	if(fillbg_struct.nframe >1)
> 	{
> 		frame_updatebg(raw_img,img);
> 	}	
> 
> 	//å¼€å§‹æ—¶æ²¡ç›®æ ‡æ—¶ç”¨ç¬¬ä¸€æ¬¡çš„(é˜²æ­¢å¼€å§‹äººä¸åŠ¨ä¸¢ç›®æ ‡) ;
> 	if (!fillbg_struct.isfillok && fillbg_struct.rect_old.size() <= 0 
> 		&&fillbg_struct.nframe == 2 && !frame_s.is_body_down && !fillbg_struct.body_move) 
> 	{
> 		Rect t = fillbg_struct.fist_fillrect[0];
> 		Rect r = Rect(t.x+t.width/2-fillbg_struct.body_width,t.y+t.height/2-fillbg_struct.body_width,
> 			           2*fillbg_struct.body_width,2*fillbg_struct.body_width);			    
> 		r &= Rect(0,0,img.cols,img.rows);
> 		fillbg_struct.rect_old.push_back(r);
> 	}
> 
> 	//åˆ¤æ–­æ˜¯å¦æ˜¯é”™è¯¯çš„æ›´æ–°;
> 	is_need_fillbg_twice(img);
> 
> 	//LUVç®—æ³•ï¼Œåˆå§‹æ›´æ–°å®Œä¹‹åï¼Œæ ¹æ®å¾—åˆ°å¾—rectå’Œå®æ—¶çš„å›¾åƒä»¥åŠbgå›¾åƒï¼Œæ›´æ–°bgå›¾;
> 	if (!fillbg_struct.isfillok) 
> 	{	
> 		fillbg_LUV(img);
> 	}
> 
> 	//å¦‚æœåŠåˆ†é’Ÿå†…ä¸€ä¸ªç›®æ ‡ä¹Ÿæ²¡æœ‰ï¼Œåˆ™æ›´æ–°æ•´ä¸ªèƒŒæ™¯åŒº;
> 	//norect_update_bg(img);
> 
> 	//è°ƒè¯•é€‰é¡¹;
> 	if (atoi(cfg_->get_value("debug", "0")) > 0)
> 	{
> 		if (!fillbg_struct.bg.empty()) 
> 		{
> 			imshow("bg", fillbg_struct.bg);
> 			waitKey(1);
> 		}
> 	}
> 	//ä¸¤ä¸ªç›®æ ‡ç›¸è·ä¸€å®šè·ç¦»æ—¶è¿›è¡Œèåˆ;(å‰é¢èåˆçš„å¤§æ¦‚æ˜¯ä¸€ä¸ªç›®æ ‡çš„è·ç¦»);
> 	rect_fusion2( fillbg_struct.rect_old,fillbg_struct.mog2_interval1);
> 	if(!fillbg_struct.isfillok)
> 	{
> 		first_rect = fillbg_struct.fist_fillrect;
> 	}
> 	r = fillbg_struct.rect_old;
> 	if (fillbg_struct.rect_old.size() > 0) 
> 	{	
> 		has_rect = true;
> 	}
> 	return has_rect;
1323c1317
< //  bool masked = false;
---
> //	bool masked = false;
1325,1326c1319,1320
< //  const char *pts = cfg_->get_value(key, "0");
< //  std::vector < Point > points;
---
> //	const char *pts = cfg_->get_value(key, "0");
> //	std::vector < Point > points;
1328,1337c1322,1331
< //  if (pts) {
< //      char *data = strdup(pts);
< //      char *p = strtok(data, ";");
< //      while (p) {
< //          // æ¯ä¸ªPoint ä½¿"x,y" æ ¼å¼ ;
< //          int x, y;
< //          if (sscanf(p, "%d,%d", &x, &y) == 2) {
< //              CvPoint pt = { x, y };
< //              points.push_back(pt);
< //          }
---
> //	if (pts) {
> //		char *data = strdup(pts);
> //		char *p = strtok(data, ";");
> //		while (p) {
> //			// æ¯ä¸ªPoint ä½¿"x,y" æ ¼å¼ ;
> //			int x, y;
> //			if (sscanf(p, "%d,%d", &x, &y) == 2) {
> //				CvPoint pt = { x, y };
> //				points.push_back(pt);
> //			}
1339,1342c1333,1336
< //          p = strtok(0, ";");
< //      }
< //      free(data);
< //  }
---
> //			p = strtok(0, ";");
> //		}
> //		free(data);
> //	}
1344,1353c1338,1347
< //  if (points.size() > 3) {
< //      int n = points.size();
< //      const Point **pts =
< //          (const Point **) alloca(sizeof(const Point *) * points.size());
< //      for (int i = 0; i < n; i++) {
< //          pts[i] = &points[i];
< //      }
< //      fillPoly(img, pts, &n, 1, CV_RGB(255, 255, 255));
< //      masked = true;
< //  }
---
> //	if (points.size() > 3) {
> //		int n = points.size();
> //		const Point **pts =
> //		    (const Point **) alloca(sizeof(const Point *) * points.size());
> //		for (int i = 0; i < n; i++) {
> //			pts[i] = &points[i];
> //		}
> //		fillPoly(img, pts, &n, 1, CV_RGB(255, 255, 255));
> //		masked = true;
> //	}
1355c1349
< //  return masked;
---
> //	return masked;
1361,1364c1355,1358
< //  /** ä» cfg ä¸­çš„å‚æ•°ï¼Œåˆ›å»º mask */
< //  //CvSize size = {video_width_, video_height_};
< //  Size size(video_width_, video_height_);
< //  Mat img; img.create(size,CV_8UC3);
---
> //	/** ä» cfg ä¸­çš„å‚æ•°ï¼Œåˆ›å»º mask */
> //	//CvSize size = {video_width_, video_height_};
> //	Size size(video_width_, video_height_);
> //	Mat img; img.create(size,CV_8UC3);
1366,1367c1360,1361
< //  if (!ismask_)
< //      img.setTo(0);
---
> //	if (!ismask_)
> //		img.setTo(0);
1369,1371c1363,1365
< //  if (key) {
< //      ismask_ = build_mask_internal(key, img);
< //  }
---
> //	if (key) {
> //		ismask_ = build_mask_internal(key, img);
> //	}
1373,1376c1367,1370
< //  if (key2) {
< //      build_mask_internal(key2, img);
< //  }
< //  return img;
---
> //	if (key2) {
> //		build_mask_internal(key2, img);
> //	}
> //	return img;
1379c1373
< ////è¾“å…¥åŸå§‹å›¾åƒï¼Œè¿”å›æ©ç åçš„å›¾åƒ;
---
> ////è¾“å…¥åŸå§‹å›¾åƒï¼Œè¿”å›æ©ç åçš„å›¾åƒ; 
1382,1385c1376,1379
< //  if (ismask_)        //æ˜¯å¦å¡«å……å®Œæ¯• ;
< //  {
< //      bitwise_and(img, img_mask_, img);
< //  }
---
> //	if (ismask_)		//æ˜¯å¦å¡«å……å®Œæ¯• ;
> //	{
> //		bitwise_and(img, img_mask_, img);
> //	} 
1395,1424c1389,1418
<     bool masked = false;
<     const char *pts = cfg_->get_value(key, "0");
<     std::vector < Point > points;
<     if (pts) {
<         char *data = strdup(pts);
<         char *p = strtok(data, ";");
<         while (p) {
<             // æ¯ä¸ªPoint ä½¿"x,y" æ ¼å¼ ;
<             int x, y;
<             if (sscanf(p, "%d,%d", &x, &y) == 2) {
<                 CvPoint pt = { x, y };
<                 pt.x = pt.x-mask_rc.x; pt.y = pt.y - mask_rc.y;//++++++++++++++++;
<                 points.push_back(pt);
<             }
< 
<             p = strtok(0, ";");
<         }
<         free(data);
<     }
< 
<     if (points.size() > 3) {
<         int n = points.size();
<         const Point **pts =
<             (const Point **) alloca(sizeof(const Point *) * points.size());
<         for (int i = 0; i < n; i++) {
<             pts[i] = &points[i];
<         }
<         fillPoly(img, pts, &n, 1, CV_RGB(255, 255, 255));
<         masked = true;
<     }
---
> 	bool masked = false;
> 	const char *pts = cfg_->get_value(key, "0");
> 	std::vector < Point > points;
> 	if (pts) {
> 		char *data = strdup(pts);
> 		char *p = strtok(data, ";");
> 		while (p) {
> 			// æ¯ä¸ªPoint ä½¿"x,y" æ ¼å¼ ;
> 			int x, y;
> 			if (sscanf(p, "%d,%d", &x, &y) == 2) {
> 				CvPoint pt = { x, y };
> 				pt.x = pt.x-mask_rc.x; pt.y = pt.y - mask_rc.y;//++++++++++++++++;
> 				points.push_back(pt);
> 			}
> 
> 			p = strtok(0, ";");
> 		}
> 		free(data);
> 	}
> 
> 	if (points.size() > 3) {
> 		int n = points.size();
> 		const Point **pts =
> 		    (const Point **) alloca(sizeof(const Point *) * points.size());
> 		for (int i = 0; i < n; i++) {
> 			pts[i] = &points[i];
> 		}
> 		fillPoly(img, pts, &n, 1, CV_RGB(255, 255, 255));
> 		masked = true;
> 	}
1426c1420
<     return masked;
---
> 	return masked;
1432,1438c1426,1428
<     /** ä» cfg ä¸­çš„å‚æ•°ï¼Œåˆ›å»º mask */
<     CvSize size = {mask_rc.width, mask_rc.height};
<     Mat img; img.create(size,CV_8UC3);
< 
<     bool is_mask = false;
<     if (!is_mask)
<         img.setTo(0);
---
> 	/** ä» cfg ä¸­çš„å‚æ•°ï¼Œåˆ›å»º mask */
> 	CvSize size = {mask_rc.width, mask_rc.height};
> 	Mat img; img.create(size,CV_8UC3);
1440,1442c1430,1432
<     if (key) {
<         is_mask = build_mask_internal(key, img, mask_rc);
<     }
---
> 	bool is_mask = false;
> 	if (!is_mask)
> 		img.setTo(0);
1444,1446c1434,1440
<     if (key2) {
<         build_mask_internal(key2, img, mask_rc);
<     }
---
> 	if (key) {
> 		is_mask = build_mask_internal(key, img, mask_rc);
> 	}
> 
> 	if (key2) {
> 		build_mask_internal(key2, img, mask_rc);
> 	}
1448c1442
<     img.copyTo(img_mask);
---
> 	img.copyTo(img_mask);
1450c1444
<     return is_mask;
---
> 	return is_mask;
1453c1447
< //è¾“å…¥åŸå§‹å›¾åƒï¼Œè¿”å›æ©ç åçš„å›¾åƒ;
---
> //è¾“å…¥åŸå§‹å›¾åƒï¼Œè¿”å›æ©ç åçš„å›¾åƒ; 
1456c1450
<     bitwise_and(img, img_mask, img);
---
> 	bitwise_and(img, img_mask, img);
1463,1491c1457,1485
<     std::vector<cv::Point> points;
<     /*if (!pts) {
<         points.push_back(cv::Point(0, 0));
<         points.push_back(cv::Point(0, atoi(cfg_->get_value("video_width", "960"))));
<         points.push_back(cv::Point(atoi(cfg_->get_value("video_width", "960")),
<             atoi(cfg_->get_value("video_height", "540"))));
<         points.push_back(cv::Point(atoi(cfg_->get_value("video_width", "960")), 0));
<         return points;
<     }*/
< 
<     char key[64];
<     if (pts)
<     {
<         char *data = strdup(pts);
<         char *p = strtok(data, ";");
<         while (p)
<         {
<             // æ¯ä¸ªPoint ä½¿"x,y" æ ¼å¼;
<             int x, y;
<             if (sscanf(p, "%d,%d", &x, &y) == 2)
<             {
<                 CvPoint pt = { x, y };
<                 points.push_back(pt);
<             }
< 
<             p = strtok(0, ";");
<         }
<         free(data);
<     }
---
> 	std::vector<cv::Point> points;
> 	/*if (!pts) {
> 		points.push_back(cv::Point(0, 0));
> 		points.push_back(cv::Point(0, atoi(cfg_->get_value("video_width", "960"))));
> 		points.push_back(cv::Point(atoi(cfg_->get_value("video_width", "960")), 
> 			atoi(cfg_->get_value("video_height", "540"))));
> 		points.push_back(cv::Point(atoi(cfg_->get_value("video_width", "960")), 0));
> 		return points;
> 	}*/
> 
> 	char key[64];
> 	if (pts) 
> 	{
> 		char *data = strdup(pts);
> 		char *p = strtok(data, ";");
> 		while (p) 
> 		{
> 			// æ¯ä¸ªPoint ä½¿"x,y" æ ¼å¼;
> 			int x, y;
> 			if (sscanf(p, "%d,%d", &x, &y) == 2) 
> 			{
> 				CvPoint pt = { x, y };
> 				points.push_back(pt);
> 			}
> 
> 			p = strtok(0, ";");
> 		}
> 		free(data);
> 	}
1493c1487
<     return points;
---
> 	return points;
1499c1493
<     return (a.x < b.x);
---
> 	return (a.x < b.x);
1506c1500
<     return (a.y < b.y);
---
> 	return (a.y < b.y);
1513,1524c1507,1518
<     cv::Rect rect;
<     int min_x,min_y;
<     int max_x,max_y;
<     std::sort(pt.begin(), pt.end(), cmp_min_x);
<     min_x = pt[0].x;
<     max_x = pt[pt.size()-1].x;
<     std::sort(pt.begin(), pt.end(), cmp_min_y);
<     min_y = pt[0].y;
<     max_y = pt[pt.size()-1].y;
<     rect = Rect(min_x,min_y,(max_x-min_x),(max_y-min_y));
<     rect &= Rect(0,0,video_width_,video_height_);
<     return rect;
---
> 	cv::Rect rect;
> 	int min_x,min_y;
> 	int max_x,max_y;
> 	std::sort(pt.begin(), pt.end(), cmp_min_x);
> 	min_x = pt[0].x;
> 	max_x = pt[pt.size()-1].x;
> 	std::sort(pt.begin(), pt.end(), cmp_min_y);
> 	min_y = pt[0].y;
> 	max_y = pt[pt.size()-1].y;
> 	rect = Rect(min_x,min_y,(max_x-min_x),(max_y-min_y));
> 	rect &= Rect(0,0,video_width_,video_height_);
> 	return rect;
1529,1562c1523,1556
<     Rect masked;
<     std::vector<cv::Point> pt_vector,pt_vector_1,pt_vector_2;
<     if(cb_date)
<     {
<         pt_vector_1 = load_roi(cb_date);
<         if(pt_vector_1.size()>2)
<         {
<             for(int i = 0;i<pt_vector_1.size();i++)
<             {
<                 pt_vector.push_back(pt_vector_1[i]);
<             }
<         }
<     }
<     if(cb_date_2)
<     {
<         pt_vector_2 = load_roi(cb_date_2);
<         if(pt_vector_2.size()>2)
<         {
<             for(int i = 0;i<pt_vector_2.size();i++)
<             {
<                 pt_vector.push_back(pt_vector_2[i]);
<             }
<         }
<     }
<     if(pt_vector_1.size() < 3 && pt_vector_2.size() < 3)
<     {
<         masked = init_rect;
<     }
<     else
<     {
<         masked = get_point_rect(pt_vector);
<     }
<     return masked;
< }
---
> 	Rect masked;
> 	std::vector<cv::Point> pt_vector,pt_vector_1,pt_vector_2;
> 	if(cb_date) 
> 	{
> 		pt_vector_1 = load_roi(cb_date);
> 		if(pt_vector_1.size()>2) 
> 		{
> 			for(int i = 0;i<pt_vector_1.size();i++)
> 			{
> 				pt_vector.push_back(pt_vector_1[i]);
> 			}
> 		}
> 	}	
> 	if(cb_date_2)
> 	{
> 		pt_vector_2 = load_roi(cb_date_2);
> 		if(pt_vector_2.size()>2) 
> 		{
> 			for(int i = 0;i<pt_vector_2.size();i++)
> 			{
> 				pt_vector.push_back(pt_vector_2[i]);
> 			}
> 		}
> 	}	
> 	if(pt_vector_1.size() < 3 && pt_vector_2.size() < 3)
> 	{
> 		masked = init_rect;
> 	}
> 	else
> 	{
> 		masked = get_point_rect(pt_vector);
> 	}
> 	return masked;
> }
\ æ–‡ä»¶å°¾æ²¡æœ‰ newline å­—ç¬¦
diff libdetect_t_bak/detect_t.h libdetect_t_bak2/detect_t.h
5c5
< #include<opencv2/opencv1.hpp>
---
> #include<opencv2/opencv.hpp>
7,8c7
< #include <cstdio>
< #include "KVConfig.h"
---
> #include "../libkvconfig/KVConfig.h"
38c37
< 
---
> 	
55c54
< 	Mat bg;//±³¾°Í¼;
---
> 	Mat bg;//±³¾°Í¼;	
63c62
< //	CvMemStorage* storage;
---
> //	CvMemStorage* storage; 
83c82
< 	int num;
---
> 	int num;	
106c105
< 	Mat buffer[5];
---
> 	Mat buffer[5];	
148c147
< 
---
> 	
155c154
< public:
---
> public:	
160,164c159,163
< 	void upbody_bgupdate( Mat upbody_img);// +++
<     void get_upbody(Mat img_upbody );
< 	void upbody_luv_method(const Mat &img );
< 	void upbody_updatebg_slow(Mat img,Rect r,double learn_rate);
< 	void mog_method(Mat img);
---
> 	void TeacherDetecting::upbody_bgupdate( Mat upbody_img);// +++
>     void TeacherDetecting::get_upbody(Mat img_upbody );
> 	void TeacherDetecting::upbody_luv_method(const Mat &img );
> 	void TeacherDetecting::upbody_updatebg_slow(Mat img,Rect r,double learn_rate);
> 	void TeacherDetecting::mog_method(Mat img);
231c230
< #endif
---
> #endif
\ æ–‡ä»¶å°¾æ²¡æœ‰ newline å­—ç¬¦
åªåœ¨ libdetect_t_bak å­˜åœ¨ï¼šdetect_t.o
diff libdetect_t_bak/hog.cpp libdetect_t_bak2/hog.cpp
25c25
< 
---
>  
31c31
< 
---
>  
42c42
< 
---
>  
47c47
< 
---
>  
49,50c49,50
<      fread(&(kernel_type),sizeof(long),1,modelfl);
< 
---
>      fread(&(kernel_type),sizeof(long),1,modelfl);   
>  
54c54
< 
---
>  
57c57
< 
---
>  
62c62
< 
---
>  
69c69
< 
---
>  
72c72
< 
---
>  
76c76
< 
---
>  
80c80
< 
---
>  
83c83
< 
---
>  
89c89
< 
---
>  
97c97
< 
---
>  
100c100
< 
---
>  
107,145c107,128
<     hog.winSize = winsize;
<    // hog.blockSize = cv::Size(16, 16);
<    // hog.blockStride = cv::Size(8, 8);
<     std::vector<float> vec = load_lear_model(alt_file);
<     if (vec.empty())
<         throw std::runtime_error("zk_hog_detector: can't find the alt file");
<     //for(std::vector<float>::iterator iter = vec.begin(); iter != vec.end(); iter++)
<     //{
<     //    printf("%lf ",*iter);
<     //}
<     //printf("\n");
<     hog.blockSize.width = 16;
<     hog.blockSize.height = 16;
<     hog.blockStride.width = 2;
<     hog.blockStride.height = 2;
<     printf("%d,%d\n",hog.winSize.width, hog.winSize.height);
<     printf("%d,%d,%d,%d\n",hog.blockSize.width, hog.blockSize.height, hog.blockStride.width, hog.blockStride.height);
<     printf("line=%d\n",__LINE__);
<     hog.setSVMDetector(vec);
<     printf("line=%d\n",__LINE__);
<     //************************
<     UP_BODY_WIDTH =  atoi(cfg->get_value("t_upbody_w","70"));
<     UP_BODY_HEIGHT = atoi(cfg->get_value("t_upbody_h","90"));
<     det_.long_inter_time = atoi(cfg->get_value("t_hog_l_inter_time","1000"));//Ã¿¼ä¸ô100ºÁÃë¼ì²âÒ»´ÎÍ·¼ç;
<     det_.short_inter_time = atoi(cfg->get_value("t_hog__s_inter_time","200"));//Ã¿¼ä¸ô100ºÁÃë¼ì²âÒ»´ÎÍ·¼ç;
<     det_.inter_time =det_.long_inter_time;//Ã¿¼ä¸ô100ºÁÃë¼ì²âÒ»´ÎÍ·¼ç;
<     det_.start = false;
<     det_.timeing_start = false;
<     if(atoi(cfg->get_value("debug","0"))>0)
<         is_debug = true;
<     else
<         is_debug = false;
< 
<     //***********************
<     cf_ = new tracker_camshift(cfg->get_value("trace_camshift_meta_file", "data/hist.yaml"));
<     printf("line=%d\n",__LINE__);
<     if(atoi(cfg->get_value("t_upbody_strict","0"))>0) det_.is_strict = true;
<     else det_.is_strict = false;
<     printf("line=%d\n",__LINE__);
---
> 	hog.winSize = winsize;
> 	std::vector<float> vec = load_lear_model(alt_file); 
> 	if (vec.empty())
> 		throw std::runtime_error("zk_hog_detector: can't find the alt file");
> 	hog.setSVMDetector(vec);
> 	//************************
> 	UP_BODY_WIDTH =  atoi(cfg->get_value("t_upbody_w","70"));
> 	UP_BODY_HEIGHT = atoi(cfg->get_value("t_upbody_h","90"));
> 	det_.long_inter_time = atoi(cfg->get_value("t_hog_l_inter_time","1000"));//Ã¿¼ä¸ô100ºÁÃë¼ì²âÒ»´ÎÍ·¼ç;
> 	det_.short_inter_time = atoi(cfg->get_value("t_hog__s_inter_time","200"));//Ã¿¼ä¸ô100ºÁÃë¼ì²âÒ»´ÎÍ·¼ç;
> 	det_.inter_time =det_.long_inter_time;//Ã¿¼ä¸ô100ºÁÃë¼ì²âÒ»´ÎÍ·¼ç;
> 	det_.start = false;
> 	det_.timeing_start = false;
> 	if(atoi(cfg->get_value("debug","0"))>0) 
> 		is_debug = true;
> 	else
> 		is_debug = false;
> 
> 	//***********************
> 	cf_ = new tracker_camshift(cfg->get_value("trace_camshift_meta_file", "data/hist.yaml"));
> 	if(atoi(cfg->get_value("t_upbody_strict","0"))>0) det_.is_strict = true; 
> 	else det_.is_strict = false;
150,152c133,135
<     std::vector<cv::Rect> found;
<     hog.detectMultiScale(gray, found, 0, cv::Size(16, 16), cv::Size(), scale, group_threshold);
<     return found;
---
> 	std::vector<cv::Rect> found;
> 	hog.detectMultiScale(gray, found, 0, cv::Size(16, 16), cv::Size(), scale, group_threshold);
> 	return found;
155,157c138,140
< //À©Õ¹ÕÚµ²ÔË¶¯Çø;
< //ÊäÈë£ºtarget£¨ÕÚµ²ºì¿òĞòÁĞ£©
< //Êä³ö£ºÀ©Õ¹ºóÕÚµ²ºì¿òĞòÁĞ£¨ÓÃÒÔ½øĞĞÍ·¼çÊ¶±ğ£©
---
> //À©Õ¹ÕÚµ²ÔË¶¯Çø; 
> //ÊäÈë£ºtarget£¨ÕÚµ²ºì¿òĞòÁĞ£© 
> //Êä³ö£ºÀ©Õ¹ºóÕÚµ²ºì¿òĞòÁĞ£¨ÓÃÒÔ½øĞĞÍ·¼çÊ¶±ğ£© 
159,170c142,153
< {
<     //×óÓÒÀ©Õ¹Êµ¼ÊÈË¿íµÄ2±¶;
<     int up_w = (image.width/480) * UP_BODY_WIDTH;
<     int up_h = (image.width/480) * UP_BODY_HEIGHT;
< 
<     target.x = target.x+target.width/2 - (up_w);
<     target.width = (up_w)*2;
< 
<     target.y = target.y - (up_h + 30);
<     target.height = 2 * (up_h+30);
< 
<     target &= cv::Rect(0,0,image.width,image.height);
---
> { 
> 	//×óÓÒÀ©Õ¹Êµ¼ÊÈË¿íµÄ2±¶; 
> 	int up_w = (image.width/480) * UP_BODY_WIDTH;
> 	int up_h = (image.width/480) * UP_BODY_HEIGHT;
> 
> 	target.x = target.x+target.width/2 - (up_w);
> 	target.width = (up_w)*2;
> 
> 	target.y = target.y - (up_h + 30);
> 	target.height = 2 * (up_h+30);
> 	
> 	target &= cv::Rect(0,0,image.width,image.height);
176,188c159,171
<     float ratio;
<     //°´±ÈÀı½øĞĞËõĞ¡£¨ÒÔ¼õÉÙÊ¶±ğÊ±¼ä£©;
<     float w_ratio = HOG_MIN_WIDTH*1.0/((source_width/480)*UP_BODY_WIDTH);
<     float h_ratio = HOG_MIN_HEIGHT*1.0/((source_width/480)*UP_BODY_HEIGHT);
<     if(w_ratio>h_ratio)
<     {
<         ratio = w_ratio;
<     }
<     else
<     {
<         ratio = h_ratio;
<     }
<     return ratio;
---
> 	float ratio;
> 	//°´±ÈÀı½øĞĞËõĞ¡£¨ÒÔ¼õÉÙÊ¶±ğÊ±¼ä£©;
> 	float w_ratio = HOG_MIN_WIDTH*1.0/((source_width/480)*UP_BODY_WIDTH);
> 	float h_ratio = HOG_MIN_HEIGHT*1.0/((source_width/480)*UP_BODY_HEIGHT);
> 	if(w_ratio>h_ratio)
> 	{
> 		ratio = w_ratio;
> 	}
> 	else
> 	{
> 		ratio = h_ratio;
> 	}
> 	return ratio;
195,276c178,259
<     bool is_face = false;
<     cv::Rect rc_temp = rc;
<     expend_target_rect(rc_temp,Size(img.cols,img.rows));
<     float ratio = set_zoom_ratio(img.cols);
<     Mat img_mask = Mat(img,rc_temp);
<     Mat img_mask_gray(img.cols,img.rows,CV_8UC1);
<     cvtColor(img_mask,img_mask_gray,CV_BGR2GRAY);
<     resize(img_mask_gray,img_mask_gray,Size(img_mask_gray.cols*ratio, img_mask_gray.rows*ratio));
<     std::vector<cv::Rect> up_body_t = zk_hog_upperbody(img_mask_gray,1);
< 
<     std::vector<cv::Rect> up_body;
<     if(up_body_t.size()>0)
<     {
<         for(int i = 0;i<up_body_t.size();i++)
<         {
<             if (is_debug)
<             {
<                rectangle(img_mask_gray, up_body_t[i], Scalar(0, 0, 0), 2);//ËùÓĞ·Å´óÍ·¼ç¿ò+++++++
<             }
<             //ÏÈ·Å´ó
<             up_body_t[i].x /= ratio;
<             up_body_t[i].y /= ratio;
<             up_body_t[i].width /= ratio;
<             up_body_t[i].height /= ratio;
< 
<             up_body_t[i].x = up_body_t[i].x+rc_temp.x;
<             up_body_t[i].y = up_body_t[i].y+rc_temp.y;
<             up_body_t[i] &= cv::Rect(0,0,img.cols,img.rows);
<             if (is_debug)
<             {
<                 rectangle(img, up_body_t[i], Scalar(0, 0, 255), 2);//ËùÓĞÍ·¼ç¿ò+++++++
<             }
<             //ÓĞÈËÁ³Ö±·½Í¼µÄÍ·¼ç¿ò;
<             cv::Rect r_t = up_body_t[i];
<             cf_->set_track_window(r_t);
<             cv::Rect face = cf_->process(img,true);
<             if(face.width>0&&face.height>0 && cf_->is_face(face,up_body_t[i]))
<             {
<                 up_body.push_back(up_body_t[i]);
<                 if (is_debug)
<                 {
<                     rectangle(img, face, Scalar(255, 0, 0), 2);//ËùÓĞÍ·¼ç¿ò+++++++
<                 }
<             }
<         }
<         if(!det_.is_strict)
<         {
<             if(up_body.size()<1)//Èç¹û¶¼Ã»ÓĞÈËÁ³£¬Ôò»¹ÊÇ±£³ÖÔ­À´µÄ;
<             {up_body = up_body_t;}
<         }
<     }
<     //Ñ¡È¡ºÍÄ¿±ê¿ò×óÓÒÆ«ÒÆ×î½üµÄÄ¿±ê;
<     if(up_body.size()>0)
<     {
<         is_face = true;
<         face = up_body[0];
<         Point t_up = Point((up_body[0].x+up_body[0].width/2),(up_body[0].y+up_body[0].height/2));
<         Point t_rc = Point((rc.x+rc.width/2),(rc.y+rc.height/2));
<         float len_min = abs(t_up.x-t_rc.x);
<         for(int i = 1;i<up_body.size();i++)
<         {
<             Point t_up = Point((up_body[i].x+up_body[i].width/2),(up_body[i].y+up_body[i].height/2));
<             Point t_rc = Point((rc.x+rc.width/2),(rc.y+rc.height/2));
<             float len = abs(t_up.x-t_rc.x);
<             if(len<len_min)
<             {
<                 len_min = len;
<                 face = up_body[i];
<             }
<         }
<         if (is_debug)
<         {
<             rectangle(img, face, Scalar(255, 255, 0), 4);//ÕıÈ·Í·¼ç¿ò+++++++
<         }
<     }
<     if (is_debug)
<     {
<         rectangle(img, rc_temp, Scalar(255, 255, 255), 2);//+++++++
<         imshow("img_mask_gray", img_mask_gray);//++++++++++
<         waitKey(1);
<     }
<     return is_face;
---
> 	bool is_face = false;
> 	cv::Rect rc_temp = rc;
> 	expend_target_rect(rc_temp,Size(img.cols,img.rows));	
> 	float ratio = set_zoom_ratio(img.cols);
> 	Mat img_mask = Mat(img,rc_temp);
> 	Mat img_mask_gray(img.cols,img.rows,CV_8UC1);
> 	cvtColor(img_mask,img_mask_gray,CV_BGR2GRAY);	
> 	resize(img_mask_gray,img_mask_gray,Size(img_mask_gray.cols*ratio, img_mask_gray.rows*ratio));
> 	std::vector<cv::Rect> up_body_t = zk_hog_upperbody(img_mask_gray,1);
> 
> 	std::vector<cv::Rect> up_body;
> 	if(up_body_t.size()>0)
> 	{
> 		for(int i = 0;i<up_body_t.size();i++)
> 		{
> 			if (is_debug)
> 			{			
> 			   rectangle(img_mask_gray, up_body_t[i], Scalar(0, 0, 0), 2);//ËùÓĞ·Å´óÍ·¼ç¿ò+++++++
> 			}
> 			//ÏÈ·Å´ó
> 			up_body_t[i].x /= ratio;
> 			up_body_t[i].y /= ratio;
> 			up_body_t[i].width /= ratio;
> 			up_body_t[i].height /= ratio;
> 
> 			up_body_t[i].x = up_body_t[i].x+rc_temp.x;
> 			up_body_t[i].y = up_body_t[i].y+rc_temp.y;
> 			up_body_t[i] &= cv::Rect(0,0,img.cols,img.rows);
> 			if (is_debug)
> 			{
> 				rectangle(img, up_body_t[i], Scalar(0, 0, 255), 2);//ËùÓĞÍ·¼ç¿ò+++++++
> 			}
> 			//ÓĞÈËÁ³Ö±·½Í¼µÄÍ·¼ç¿ò;
> 			cv::Rect r_t = up_body_t[i];
> 	        cf_->set_track_window(r_t);
> 			cv::Rect face = cf_->process(img,true);
> 			if(face.width>0&&face.height>0 && cf_->is_face(face,up_body_t[i]))
> 			{
> 				up_body.push_back(up_body_t[i]);
> 				if (is_debug)
> 				{
> 					rectangle(img, face, Scalar(255, 0, 0), 2);//ËùÓĞÍ·¼ç¿ò+++++++
> 				}
> 			}			
> 		}
> 		if(!det_.is_strict)
> 		{
> 			if(up_body.size()<1)//Èç¹û¶¼Ã»ÓĞÈËÁ³£¬Ôò»¹ÊÇ±£³ÖÔ­À´µÄ;
> 		    {up_body = up_body_t;}
> 		}	
> 	}
> 	//Ñ¡È¡ºÍÄ¿±ê¿ò×óÓÒÆ«ÒÆ×î½üµÄÄ¿±ê;
> 	if(up_body.size()>0)
> 	{
> 		is_face = true;
> 		face = up_body[0];
> 		Point t_up = Point((up_body[0].x+up_body[0].width/2),(up_body[0].y+up_body[0].height/2));
> 		Point t_rc = Point((rc.x+rc.width/2),(rc.y+rc.height/2));
> 		float len_min = abs(t_up.x-t_rc.x);
> 		for(int i = 1;i<up_body.size();i++)
> 		{
> 			Point t_up = Point((up_body[i].x+up_body[i].width/2),(up_body[i].y+up_body[i].height/2));
> 			Point t_rc = Point((rc.x+rc.width/2),(rc.y+rc.height/2));
> 			float len = abs(t_up.x-t_rc.x);
> 			if(len<len_min)
> 			{
> 				len_min = len;
> 				face = up_body[i];
> 			}
> 		}
> 		if (is_debug)
> 		{
> 			rectangle(img, face, Scalar(255, 255, 0), 4);//ÕıÈ·Í·¼ç¿ò+++++++
> 		}
> 	}
> 	if (is_debug)
> 	{
> 		rectangle(img, rc_temp, Scalar(255, 255, 255), 2);//+++++++		
> 		imshow("img_mask_gray", img_mask_gray);//++++++++++
> 		waitKey(1); 
> 	}	
> 	return is_face;
284,307c267,290
<     bool is_upbody = false;
<     bool time_ok = false;
<     if(!det_.timeing_start)
<     {
<         ftime(&det_.pre_time);ftime(&det_.cur_time);
<         det_.timeing_start = true;
<     }
<     else
<     {
<         ftime(&det_.cur_time);
<         double time = (det_.cur_time.time - det_.pre_time.time)*1000+(det_.cur_time.millitm-det_.pre_time.millitm);
<         if(time>=det_.inter_time)//ºÁÃë;
<         {
<             time_ok = true;det_.timeing_start = false;
<         }
<     }
<     if(  time_ok && r.size() == 1 && r[0].width < UP_BODY_WIDTH*(Img.cols/480)*3)
<     {
<         //fprintf(stderr,"%f**********************\n",inter);
<         is_upbody = zk_hog_detect(Img,r[0],up_body);
<         if(!is_upbody) { det_.inter_time = det_.short_inter_time;}
<         else {det_.inter_time = det_.long_inter_time;}
<     }
<     return is_upbody;
---
> 	bool is_upbody = false;
> 	bool time_ok = false;
> 	if(!det_.timeing_start)
> 	{
> 		ftime(&det_.pre_time);ftime(&det_.cur_time);
> 		det_.timeing_start = true;
> 	}
> 	else
> 	{
> 		ftime(&det_.cur_time);
> 		double time = (det_.cur_time.time - det_.pre_time.time)*1000+(det_.cur_time.millitm-det_.pre_time.millitm);
> 		if(time>=det_.inter_time)//ºÁÃë;
> 		{
> 			time_ok = true;det_.timeing_start = false;
> 		}
> 	}
> 	if(  time_ok && r.size() == 1 && r[0].width < UP_BODY_WIDTH*(Img.cols/480)*3)
> 	{
> 		//fprintf(stderr,"%f**********************\n",inter);
> 		is_upbody = zk_hog_detect(Img,r[0],up_body);
> 		if(!is_upbody) { det_.inter_time = det_.short_inter_time;}
> 		else {det_.inter_time = det_.long_inter_time;}
> 	}
> 	return is_upbody;
diff libdetect_t_bak/hog.h libdetect_t_bak2/hog.h
3,4c3,4
< #include <opencv2/opencv1.hpp>
< #include "KVConfig.h"
---
> #include <opencv2/opencv.hpp>
> #include "../libkvconfig/KVConfig.h"
34,35c34,35
< 	bool up_bd_detect(cv::Mat Img,std::vector <cv::Rect> r,cv::Rect &up_body);
< 	float set_zoom_ratio(int source_width);
---
> 	bool zk_hog_detector::up_bd_detect(cv::Mat Img,std::vector <cv::Rect> r,cv::Rect &up_body);
> 	float zk_hog_detector::set_zoom_ratio(int source_width);
39,40c39,40
< 
< };
---
> 	
> };
\ æ–‡ä»¶å°¾æ²¡æœ‰ newline å­—ç¬¦
åªåœ¨ libdetect_t_bak å­˜åœ¨ï¼šhog.o
åªåœ¨ libdetect_t_bak å­˜åœ¨ï¼šKVConfig.cpp
åªåœ¨ libdetect_t_bak å­˜åœ¨ï¼šKVConfig.cpp.bak
åªåœ¨ libdetect_t_bak å­˜åœ¨ï¼šKVConfig.h
åªåœ¨ libdetect_t_bak å­˜åœ¨ï¼šKVConfig.h.bak
åªåœ¨ libdetect_t_bak å­˜åœ¨ï¼šKVConfig.o
diff libdetect_t_bak/libdetect_t.cpp libdetect_t_bak2/libdetect_t.cpp
2,6c2,7
< //#include "detect_t.h"
< //#include "blackboard_detect.h"
< //#include "../libimagesource/image_source.h"
< //#include <string>
< //#include "hog.h"
---
> #include "detect_t.h"
> #include"blackboard_detect.h"
> #include "../libimagesource/image_source.h"
> #include <string>
> #include "hog.h"
> 
8d8
< /*
11,18c11,18
<     KVConfig *cfg_;
<     TeacherDetecting *detect_;
<     BlackboardDetecting *bd_detect_;
<     zk_hog_detector *hog_det;
<     IplImage *masked_;
<     bool t_m;
<     bool b_m;
<     std::string result_str; // FIXME: å¸Œæœ›è¶³å¤Ÿäº†;
---
> 	KVConfig *cfg_;
> 	TeacherDetecting *detect_;
> 	BlackboardDetecting *bd_detect_;
> 	//zk_hog_detector *hog_det;
> 	IplImage *masked_;
> 	bool t_m; 
> 	bool b_m;
> 	std::string result_str;	// FIXME: å¸Œæœ›è¶³å¤Ÿäº†; 
20c20
< */
---
> 
24,25c24,31
<     det_t *ctx = new det_t;
<     ctx->cfg_ = new KVConfig(cfg_name);
---
> 	det_t *ctx = new det_t;
> 	ctx->cfg_ = new KVConfig(cfg_name);
> 
> 	ctx->t_m = false; 
> 	ctx->b_m = false;
> 
> 	//const char *method = ctx->cfg_->get_value("BLACKBOARD_OR_TEACHER", "teacher");
> 	//fprintf(stderr, "======================> method=%s\n", method);
27,55c33,43
<     ctx->t_m = false;
<     ctx->b_m = false;
<     ctx->s_m = false;
< 
<     //const char *method = ctx->cfg_->get_value("BLACKBOARD_OR_TEACHER", "teacher");
<     //fprintf(stderr, "======================> method=%s\n", method);
< 
<     if (strcmp(cfg_name, "teacher_detect_trace.config") == 0)
<     {
<         ctx->t_m = true;
<         ctx->detect_ = new TeacherDetecting(ctx->cfg_);
<         //ctx->hog_det = new zk_hog_detector("data/hog_upperbody.alt", ctx->cfg_, cv::Size(100, 90));
<     }
<     else if (strcmp(cfg_name, "bd_detect_trace.config") == 0)
<     {
<         ctx->b_m = true;
<         ctx->bd_detect_ = new BlackboardDetecting(ctx->cfg_);
<     }
<     else if(strcmp(cfg_name, "student_detect_trace.config") == 0)
<     {
<         ctx->s_m = true;
<         ctx->stu_detect_ = new CStudentTrack();
<         char filename[200];
<         sprintf(filename, cfg_name);
<         ctx->stu_detect_->setdebug(false);
<         ctx->stu_detect_->setduration(30);
<         ctx->stu_detect_->readconfig(filename);
<         ctx->stu_detect_->start();
<     }
---
> 	if (strcmp(cfg_name, "teacher_detect_trace.config") == 0) 
> 	{
> 		ctx->t_m = true;
> 		ctx->detect_ = new TeacherDetecting(ctx->cfg_);
> 		//ctx->hog_det = new zk_hog_detector("data/hog_upperbody.alt", ctx->cfg_, cv::Size(100, 90));
> 	}	
> 	else if (strcmp(cfg_name, "bd_detect_trace.config") == 0) 
> 	{
> 		ctx->b_m = true;
> 		ctx->bd_detect_ = new BlackboardDetecting(ctx->cfg_);
> 	}
57c45
<     return ctx;
---
> 	return ctx;
63c51
<     delete ctx->cfg_;
---
> 	delete ctx->cfg_;
65,71c53,58
<     if(ctx->t_m)
<     {
<         delete ctx->detect_;
<         //delete ctx->hog_det;
<     }
<     else if(ctx->b_m) { delete ctx->bd_detect_; }
<     else if(ctx->s_m) {delete ctx->stu_detect_;}
---
> 	if(ctx->t_m) 
> 	{
> 		delete ctx->detect_;
> 		//delete ctx->hog_det; 
> 	}
> 	else if(ctx->b_m) { delete ctx->bd_detect_; }
73c60
<     delete ctx;
---
> 	delete ctx;
81,82c68,69
<     int offset = 0;
<     offset = sprintf(buf, "{\"stamp\":%d,", time(0));
---
> 	int offset = 0;
> 	offset = sprintf(buf, "{\"stamp\":%d,", time(0));
84,119c71,106
<     if(!is_rect)
<     {
<         offset += sprintf(buf + offset, "\"rect\":[ ],");
<     }
<     else
<     {
<         offset += sprintf(buf + offset, "\"rect\":[");
< 
<         for (int i = 0; i < r.size(); i++)
<         {
<             Rect t = r[i];
<             if (i == 0)
<                 offset +=
<                     sprintf(buf + offset,
<                         "{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
<                         t.x, t.y, t.width, t.height);
<             else
<                 offset +=
<                     sprintf(buf + offset,
<                         ",{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
<                         t.x, t.y, t.width, t.height);
<         }
< 
<         offset += sprintf(buf + offset, "],");
<     }
< 
<     if(!is_upbody)
<     {
<         offset += sprintf(buf + offset, "\"up_rect\":{\"x\":0,\"y\":0,\"width\":0,\"height\":0}");
<     }
<     else
<     {
<         offset += sprintf(buf + offset, "\"up_rect\":");
<         offset += sprintf(buf + offset,"{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
<                     upbody_rect.x, upbody_rect.y, upbody_rect.width, upbody_rect.height);
<     }
---
> 	if(!is_rect)	
> 	{
> 		offset += sprintf(buf + offset, "\"rect\":[ ],");
> 	}
> 	else
> 	{
> 		offset += sprintf(buf + offset, "\"rect\":[");
> 
> 		for (int i = 0; i < r.size(); i++) 
> 		{
> 			Rect t = r[i];
> 			if (i == 0)
> 				offset +=
> 					sprintf(buf + offset,
> 						"{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
> 						t.x, t.y, t.width, t.height);
> 			else
> 				offset +=
> 					sprintf(buf + offset,
> 						",{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
> 						t.x, t.y, t.width, t.height);
> 		}
> 
> 		offset += sprintf(buf + offset, "],");
> 	}	
> 
> 	if(!is_upbody)
> 	{
> 		offset += sprintf(buf + offset, "\"up_rect\":{\"x\":0,\"y\":0,\"width\":0,\"height\":0}");
> 	}
> 	else
> 	{
> 		offset += sprintf(buf + offset, "\"up_rect\":");
> 	    offset += sprintf(buf + offset,"{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
> 				    upbody_rect.x, upbody_rect.y, upbody_rect.width, upbody_rect.height);
> 	}
121c108
<     strcat(buf, "}");
---
> 	strcat(buf, "}");
125,173c112,160
< //void vector_to_json_t(std::vector < Rect > r, std::vector < Rect > upbody_rect,
< //            bool is_upbody, bool is_rect, char *buf)
< //{
< //  int offset = 0;
< //  offset = sprintf(buf, "{\"stamp\":%d,", time(0));
< //  if (!is_rect) {
< //      offset += sprintf(buf + offset, "\"rect\":[ ],");
< //  } else {
< //      offset += sprintf(buf + offset, "\"rect\":[");
< //      for (int i = 0; i < r.size(); i++) {
< //          Rect t = r[i];
< //          if (i == 0)
< //              offset +=
< //                  sprintf(buf + offset,
< //                      "{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
< //                      t.x, t.y, t.width, t.height);
< //          else
< //              offset +=
< //                  sprintf(buf + offset,
< //                      ",{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
< //                      t.x, t.y, t.width, t.height);
< //      }
< //      offset += sprintf(buf + offset, "],");
< //  }
< //  if (!is_upbody) {
< //      offset +=
< //          sprintf(buf + offset,
< //              "\"up_rect\":[ ]");
< //  } else {
< //      offset += sprintf(buf + offset, "\"up_rect\":[");
< //      for(int j = 0; j < upbody_rect.size(); j++){
< //
< //          Rect upbody_t = upbody_rect[j];
< //          if(j == 0){
< //              offset += sprintf(buf + offset,
< //                    "{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
< //                    upbody_t.x, upbody_t.y,
< //                    upbody_t.width, upbody_t.height);
< //          }
< //          else{
< //              offset += sprintf(buf + offset,
< //                    ",{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
< //                    upbody_t.x, upbody_t.y,
< //                    upbody_t.width, upbody_t.height);
< //          }
< //      }
< //      offset += sprintf(buf + offset, "]");
< //  }
< //  strcat(buf, "}");
---
> //void vector_to_json_t(std::vector < Rect > r, std::vector < Rect > upbody_rect,
> //		      bool is_upbody, bool is_rect, char *buf)
> //{
> //	int offset = 0;
> //	offset = sprintf(buf, "{\"stamp\":%d,", time(0));
> //	if (!is_rect) {
> //		offset += sprintf(buf + offset, "\"rect\":[ ],");
> //	} else {
> //		offset += sprintf(buf + offset, "\"rect\":[");
> //		for (int i = 0; i < r.size(); i++) {
> //			Rect t = r[i];
> //			if (i == 0)
> //				offset +=
> //				    sprintf(buf + offset,
> //					    "{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
> //					    t.x, t.y, t.width, t.height);
> //			else
> //				offset +=
> //				    sprintf(buf + offset,
> //					    ",{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
> //					    t.x, t.y, t.width, t.height);
> //		}
> //		offset += sprintf(buf + offset, "],");
> //	}
> //	if (!is_upbody) {
> //		offset +=
> //		    sprintf(buf + offset,
> //			    "\"up_rect\":[ ]");
> //	} else {
> //		offset += sprintf(buf + offset, "\"up_rect\":[");
> //		for(int j = 0; j < upbody_rect.size(); j++){
> //
> //			Rect upbody_t = upbody_rect[j];
> //			if(j == 0){
> //		        offset += sprintf(buf + offset,
> //					  "{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
> //					  upbody_t.x, upbody_t.y,
> //					  upbody_t.width, upbody_t.height);
> //			}
> //			else{
> //				offset += sprintf(buf + offset,
> //					  ",{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
> //					  upbody_t.x, upbody_t.y,
> //					  upbody_t.width, upbody_t.height);
> //			}
> //		}
> //		offset += sprintf(buf + offset, "]");
> //	}
> //	strcat(buf, "}");
181,199c168,186
<     int offset = 0;
<     offset = sprintf(buf, "{\"stamp\":%d,", time(0));
<     offset += sprintf(buf + offset, "\"area\":%d,",area);
<     offset += sprintf(buf + offset, "\"rect\":[");
< 
<     for (int i = 0; i < r.size(); i++)
<     {
<         Rect t = r[i];
<         if (i == 0)
<             offset +=
<                 sprintf(buf + offset,
<                     "{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
<                     t.x, t.y, t.width, t.height);
<         else
<             offset +=
<                 sprintf(buf + offset,
<                     ",{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
<                     t.x, t.y, t.width, t.height);
<     }
---
> 	int offset = 0;
> 	offset = sprintf(buf, "{\"stamp\":%d,", time(0));
> 	offset += sprintf(buf + offset, "\"area\":%d,",area);
> 	offset += sprintf(buf + offset, "\"rect\":[");
> 
> 	for (int i = 0; i < r.size(); i++) 
> 	{
> 		Rect t = r[i];
> 		if (i == 0)
> 			offset +=
> 			    sprintf(buf + offset,
> 				    "{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
> 				    t.x, t.y, t.width, t.height);
> 		else
> 			offset +=
> 			    sprintf(buf + offset,
> 				    ",{\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d}",
> 				    t.x, t.y, t.width, t.height);
> 	}
201c188
<     strcat(buf, "]}");
---
> 	strcat(buf, "]}");
208,209c195
< //char *det_detect(det_t * ctx, zifImage * img)
< char *det_detect(det_t * ctx, cv::Mat &Img)
---
> char *det_detect(det_t * ctx, zifImage * img)
211,467c197,372
<     char *str = (char*)alloca(BUFSIZE);
<     bool isrect = false;
<     std::vector < Rect > r; //ç›®æ ‡æ¡†;
<     vector < cv::Rect > first_r;//åˆå§‹è“æ¡†;
<     //Mat Img = cv::Mat(img->height, img->width, CV_8UC3, img->data[0], img->stride[0]);
< //    printf("blur begin:%ld\n",GetTickCount());
<     //blur(Img,Img,Size(3,3));
< //    printf("blur end:%ld\n",GetTickCount());
< 
<     //***************************æ•™å¸ˆæ¢æµ‹****************************
<     if(ctx->t_m)
<     {
< #if 0
<         Mat upbody_img;
<         if(atoi(ctx->cfg_->get_value("t_upbody_detect", "0"))>0)
<         {
<             upbody_img = Img.clone();
<         }
<         // è¿”å›çš„æ˜¯ä¸ªå¼•ç”¨ï¼Œè‹¥ç›´æ¥å¤„ç†ä¼šå½±å“åŸå§‹å›¾åƒ ...
<         Mat masked_img_temp = Mat(Img, ctx->detect_->masked_rect);
<         Mat masked_img;
<         masked_img_temp.copyTo(masked_img);
< 
<         if(ctx->detect_->ismask_)
<         {
<             ctx->detect_->do_mask(masked_img, ctx->detect_->img_mask_);//åšå®Œæ©ç çš„åŸå§‹å›¾åƒ;
<         }
< 
<         //è·å–æ ‡å®šåŒºå¤–æ¥çŸ©å½¢å›¾åƒ;
<         isrect = ctx->detect_->one_frame_luv(Img, masked_img, r, first_r);
<         for (int i = 0; i < r.size(); i++)
<         {
<             cv::Rect box = ctx->detect_->masked_rect;
<             r[i].x = r[i].x + box.x;
<             r[i].y = r[i].y + box.y;
<             r[i] &= cv::Rect(0, 0, Img.cols, Img.rows);
<         }
< 
<         //*********èº«é«˜è‡ªé€‚åº”è°ƒèŠ‚*************
<         cv::Rect upbody;
<         bool is_up_body = false;
<         if(atoi(ctx->cfg_->get_value("t_upbody_detect", "0")) > 0)
<         {
<              // å»å¤§å± ...
<             Mat screen_img = Mat(ctx->detect_->screen_rect.height, ctx->detect_->screen_rect.width, CV_8UC3, Scalar(0,0,0));
<             Mat Imgroi = Mat(Img, ctx->detect_->screen_rect);
<             screen_img.copyTo(Imgroi);
< 
<             // æ¢æµ‹åŒºæ©ç  ...
<             Mat masked_upbody_temp =  Mat(Img, ctx->detect_->upbody_masked_rect);
<             Mat masked_upbody;
<             masked_upbody_temp.copyTo(masked_upbody);
<             if(ctx->detect_->is_up_mask_)
<             {
<                  ctx->detect_->do_mask(masked_upbody, ctx->detect_->upbody_img_mask_);
<             }
< 
<             ctx->detect_->get_upbody(masked_upbody);
<             // ä¸€äº›é™åˆ¶æ¡ä»¶ ...
<             // 1.åŒæ—¶æœ‰ä¸€ä¸ªçº¢æ¡†å’Œä¸€ä¸ªä¸ŠåŠèº«çŸ©å½¢æ¡† ...
<             // 2.ä¸ŠåŠèº«æ¡†å®½åº¦è¦å°äºèº«ä½“å®½åº¦çš„4å€æ‰è®¤ä¸ºæ˜¯æ­£ç¡®çš„ ...
<             // 3.å½“çº¢æ¡†å’Œä¸ŠåŠèº«æ¡†æ²¡æœ‰é‡å æ—¶ä¹Ÿè®¤ä¸ºæ˜¯é”™è¯¯ä¸ŠåŠèº« ...
<             if(r.size() == 1 && ctx->detect_->up_update.upbody_rect.size() == 1)
<             {
<                 cv::Rect upbody_t = ctx->detect_->up_update.upbody_rect[0];
<                 cv::Rect t = r[0];
<                 if( upbody_t.width < t.width * 4 &&
<                     !(t.x > upbody_t.x + upbody_t.width + ctx->detect_->upbody_masked_rect.x ||
<                       t.x + t.width < upbody_t.x + ctx->detect_->upbody_masked_rect.x))
<                 {
<                      // 1ã€é˜²æ­¢åˆ°è¾¹ç¼˜æ—¶ç›®æ ‡å˜çŸ®; 2ã€é˜²æ­¢åˆ°å¤§å±ä¸¤ä¾§æ—¶ç›®æ ‡å˜çŸ®;
<                     double upbody_center = upbody_t.x + upbody_t.width/2;
<                     if((upbody_center < ctx->detect_->upbody_masked_rect.width - 15 && upbody_center > 15) &&
<                         (upbody_center + ctx->detect_->upbody_masked_rect.x < ctx->detect_->screen_rect.x - 20 ||
<                         upbody_center + ctx->detect_->upbody_masked_rect.x > ctx->detect_->screen_rect.x + ctx->detect_->screen_rect.width + 20)
<                        )
<                     {
<                         is_up_body = true;
<                         cv::Rect box = ctx->detect_->upbody_masked_rect;
<                         upbody = upbody_t;
<                         upbody.x = upbody.x + box.x;
<                         upbody.y = upbody.y + box.y;
<                         upbody &= cv::Rect(0, 0, Img.cols, Img.rows);
<                     }
<                 }
<             }
< 
<         }
<         vector_to_json_t(r, upbody, is_up_body, isrect, str);
< 
<         //***************è°ƒè¯•****************
<         if (atoi(ctx->cfg_->get_value("debug", "0")) > 0)
<         {
<             for (int i = 0; i<r.size(); i++)
<             {
<                 rectangle(Img, r[i], Scalar(0, 0, 255), 2);
<             }
< 
<             for (int i = 0; i < first_r.size(); i++)
<             {
<                 cv::Rect box = ctx->detect_->masked_rect;
<                 first_r[i].x = first_r[i].x + box.x;
<                 first_r[i].y = first_r[i].y + box.y - 20;
<                 first_r[i].height = first_r[i].height + box.y + 40;
<                 first_r[i] &= cv::Rect(0, 0, Img.cols, Img.rows);
<                 rectangle(Img, first_r[i], Scalar(255, 0, 0), 2);
<             }
< 
<             rectangle(Img, upbody, Scalar(255, 255, 255), 2);
< 
<             imshow("rawimage", Img);
<             waitKey(1);
<         }
< #endif
<         //Mat upbody_img;
<         //if(atoi(ctx->cfg_->get_value("t_upbody_detect", "0"))>0)
<         //{
<         //    upbody_img = Img.clone();
<         //}
<         // è¿”å›çš„æ˜¯ä¸ªå¼•ç”¨ï¼Œè‹¥ç›´æ¥å¤„ç†ä¼šå½±å“åŸå§‹å›¾åƒ ...
<         Mat masked_img_temp = Mat(Img, ctx->detect_->masked_rect);
<         Mat masked_img;
<         masked_img_temp.copyTo(masked_img);
< 
<         //if(ctx->detect_->ismask_)
<         //{
<         //    ctx->detect_->do_mask(masked_img, ctx->detect_->img_mask_);//åšå®Œæ©ç çš„åŸå§‹å›¾åƒ;
<         //}
<         ctx->detect_->do_mask(masked_img);
<         //è·å–æ ‡å®šåŒºå¤–æ¥çŸ©å½¢å›¾åƒ;
<         isrect = ctx->detect_->one_frame_luv(Img, masked_img, r, first_r);
<         for (int i = 0; i < r.size(); i++)
<         {
<             cv::Rect box = ctx->detect_->masked_rect;
<             r[i].x = r[i].x + box.x;
<             r[i].y = r[i].y + box.y;
<             r[i] &= cv::Rect(0, 0, Img.cols, Img.rows);
<         }
< 
<         cv::Rect upbody;
<         bool is_up_body = false;
<         if (atoi(ctx->cfg_->get_value("t_upbody_detect", "0")) > 0)
<         {
<             Mat masked_upbody = Mat(Img, ctx->detect_->upbody_masked_rect);
<             ctx->detect_->get_upbody(masked_upbody);
<             if (ctx->detect_->up_update.upbody_rect.size() > 0)
<             {
<                 cv::Rect upbody_t = ctx->detect_->up_update.upbody_rect[0];
<                 if (!(upbody_t.x + upbody_t.width / 2 > ctx->detect_->upbody_masked_rect.width - 15 || upbody_t.x + upbody_t.width / 2 < 15))
<                 {
<                     is_up_body = true;
<                     cv::Rect box = ctx->detect_->upbody_masked_rect;
<                     upbody = upbody_t;
<                     upbody.x = upbody.x + box.x;
<                     upbody.y = upbody.y + box.y;
<                     upbody &= cv::Rect(0, 0, Img.cols, Img.rows);
<                 }
<             }
<         }
<         vector_to_json_t(r, upbody, is_up_body, isrect, str);
< 
<     }
< 
<     //***************************æ¿ä¹¦æ¢æµ‹****************************
<     else if(ctx->b_m)
<     {
<         //åšæ©ç çš„åŸå§‹å›¾åƒ;
<         Mat masked_img = Mat(Img,ctx->bd_detect_->masked_rect);
<         ctx->bd_detect_->do_mask(masked_img);
< 
<         //ç›´æ¥è·å–æ ‡å®šåŒºå¤–æ¥çŸ©å½¢å›¾åƒ;
<         //ctx->bd_detect_->masked_rect &= Rect(0,0,img_t.cols, img_t.rows);
<         //isrect = ctx->bd_detect_->one_frame_bd((IplImage*)&masked_img, r);
<         isrect = ctx->bd_detect_->one_frame_bd(masked_img, r);
<         for (int i = 0; i<r.size( ); i++)
<         {
<             cv::Rect box = ctx->bd_detect_->masked_rect;
<             r[i].x = r[i].x+box.x;
<             r[i].y = r[i].y+box.y;
<             r[i] &= cv::Rect(0,0,Img.cols,Img.rows);
<         }
< 
<         //***************è°ƒè¯•****************
<         if (atoi(ctx->cfg_->get_value("debug", "0")) > 0)
<         {
<             for (int i = 0; i < r.size(); i++)
<             {
<                 rectangle(Img, r[i], Scalar(0, 0, 255), 2);
<             }
<             //imshow("rawimage", Img);
<             //imshow("masked_img", masked_img);
<             //waitKey(1);
<         }
< 
<         if (isrect)
<         {
<             bool cal1 = false; bool cal2 = false;
<             for(int i = 0; i < r.size( ); i++)
<             {
<                 cv::Point p = Point((r[i].x + r[i].width/2), (r[i].y + r[i].height/2));
<                 for(int j = 0; j < ctx->bd_detect_->masked_rect_vec.size( ); j++)
<                 {
<                     cv::Rect rect = ctx->bd_detect_->masked_rect_vec[j];
<                     if(p.x >= rect.x && p.x <= (rect.x+rect.width))
<                     {
<                         if(j == 0) cal1 = true;
<                         else if(j == 1) cal2 = true;
<                     }
<                 }
<             }
<             int area = 0;
<             if(cal1 == true && cal2 == true) area = 0;
<             else if(cal1 == true) area = 1;
<             else if(cal2 == true) area = 2;
<             else area = 0;
<             vector_to_json(r, str, area);
<         }
<         else
<         {
<             snprintf(str, BUFSIZE, "{\"stamp\": %d,\"area\":0,\"rect\": [ ] }", time(0));
<         }
< 
<     }
<     else if(ctx->s_m)
<     {
<         const char *_pre = "{\"stamp\":1234567,\"rect\":[";
<         printf("process begin:%ld\n",GetTickCount());
<         ctx->stu_detect_->process(Img);
<         printf("process end:%ld\n",GetTickCount());
<         strcpy(str, _pre);
<         bool first = true;
<         std::vector<upStudentTarget>::iterator it = ctx->stu_detect_->up_students.begin();
<         while(it != ctx->stu_detect_->up_students.end())
<         {
<             if(it->tag == 0)
<             {
<                 if(!first)
<                 {
<                     strcat(str, ",");
<                 }
<                 char tmp[128];
<                 int x = 480 * it->position.x / 480;
<                 int y = 270 * it->position.y / 360;
<                 int w = 480 * it->position.width / 480;
<                 int h = 270 * it->position.height / 360;
<                 sprintf(tmp, "{\"x\":%d,\"y\":%d, \"width\":%d, \"height\":%d}", x, y, w, h);
<                 strcat(str, tmp);
<                 first = false;
<             }
<             ++it;
<         }
<         strcat(str, "]}");
<     }
< 
<     ctx->result_str = str;
<     //return (char*)ctx->result_str.c_str( );
<     return str;
---
> 	char *str = (char*)alloca(BUFSIZE);
> 	bool isrect = false;
> 	std::vector < Rect > r;	//ç›®æ ‡æ¡†; 
> 	vector < cv::Rect > first_r;//åˆå§‹è“æ¡†; 
> 	Mat Img = cv::Mat(img->height, img->width, CV_8UC3, img->data[0], img->stride[0]);
> 	blur(Img,Img,Size(3,3));
> 
> 	//***************************æ•™å¸ˆæ¢æµ‹****************************
> 	if(ctx->t_m) 
> 	{	
> 		Mat upbody_img;
> 		if(atoi(ctx->cfg_->get_value("t_upbody_detect", "0"))>0)
> 		{
> 			upbody_img = Img.clone();
> 		}
> 		// è¿”å›çš„æ˜¯ä¸ªå¼•ç”¨ï¼Œè‹¥ç›´æ¥å¤„ç†ä¼šå½±å“åŸå§‹å›¾åƒ ...
> 		Mat masked_img_temp = Mat(Img, ctx->detect_->masked_rect);	
> 		Mat masked_img;
> 		masked_img_temp.copyTo(masked_img);
> 
> 		if(ctx->detect_->ismask_)
> 		{
> 			ctx->detect_->do_mask(masked_img, ctx->detect_->img_mask_);//åšå®Œæ©ç çš„åŸå§‹å›¾åƒ; 
> 		}
> 		
> 		//è·å–æ ‡å®šåŒºå¤–æ¥çŸ©å½¢å›¾åƒ; 		
> 		isrect = ctx->detect_->one_frame_luv(Img, masked_img, r, first_r);
> 		for (int i = 0; i < r.size(); i++) 
> 		{
> 			cv::Rect box = ctx->detect_->masked_rect;
> 			r[i].x = r[i].x + box.x;
> 			r[i].y = r[i].y + box.y;
> 			r[i] &= cv::Rect(0, 0, Img.cols, Img.rows);
> 		}
> 
> 		//*********èº«é«˜è‡ªé€‚åº”è°ƒèŠ‚*************
> 		cv::Rect upbody;
> 		bool is_up_body = false;
> 		if(atoi(ctx->cfg_->get_value("t_upbody_detect", "0")) > 0)
> 		{
> 			 // å»å¤§å± ...
> 			Mat screen_img = Mat(ctx->detect_->screen_rect.height, ctx->detect_->screen_rect.width, CV_8UC3, Scalar(0,0,0));
> 			Mat Imgroi = Mat(Img, ctx->detect_->screen_rect);
> 			screen_img.copyTo(Imgroi);
> 
> 			// æ¢æµ‹åŒºæ©ç  ...
> 			Mat masked_upbody_temp =  Mat(Img, ctx->detect_->upbody_masked_rect);
> 			Mat masked_upbody;
> 			masked_upbody_temp.copyTo(masked_upbody);
> 			if(ctx->detect_->is_up_mask_)
> 			{
> 				 ctx->detect_->do_mask(masked_upbody, ctx->detect_->upbody_img_mask_);
> 			}
> 		   
> 			ctx->detect_->get_upbody(masked_upbody);	
> 			// ä¸€äº›é™åˆ¶æ¡ä»¶ ...
> 			// 1.åŒæ—¶æœ‰ä¸€ä¸ªçº¢æ¡†å’Œä¸€ä¸ªä¸ŠåŠèº«çŸ©å½¢æ¡† ...
> 			// 2.ä¸ŠåŠèº«æ¡†å®½åº¦è¦å°äºèº«ä½“å®½åº¦çš„4å€æ‰è®¤ä¸ºæ˜¯æ­£ç¡®çš„ ...
> 			// 3.å½“çº¢æ¡†å’Œä¸ŠåŠèº«æ¡†æ²¡æœ‰é‡å æ—¶ä¹Ÿè®¤ä¸ºæ˜¯é”™è¯¯ä¸ŠåŠèº« ...
> 			if(r.size() == 1 && ctx->detect_->up_update.upbody_rect.size() == 1)
> 			{
> 				cv::Rect upbody_t = ctx->detect_->up_update.upbody_rect[0];
> 				cv::Rect t = r[0];
> 				if( upbody_t.width < t.width * 4 && 
> 					!(t.x > upbody_t.x + upbody_t.width + ctx->detect_->upbody_masked_rect.x ||
> 				      t.x + t.width < upbody_t.x + ctx->detect_->upbody_masked_rect.x))
> 				{
> 					 // 1ã€é˜²æ­¢åˆ°è¾¹ç¼˜æ—¶ç›®æ ‡å˜çŸ®; 2ã€é˜²æ­¢åˆ°å¤§å±ä¸¤ä¾§æ—¶ç›®æ ‡å˜çŸ®;
> 					double upbody_center = upbody_t.x + upbody_t.width/2;
> 					if((upbody_center < ctx->detect_->upbody_masked_rect.width - 15 && upbody_center > 15) &&
> 						(upbody_center + ctx->detect_->upbody_masked_rect.x < ctx->detect_->screen_rect.x - 20 || 
> 						upbody_center + ctx->detect_->upbody_masked_rect.x > ctx->detect_->screen_rect.x + ctx->detect_->screen_rect.width + 20)
> 					   )
> 					{
> 						is_up_body = true;			
> 						cv::Rect box = ctx->detect_->upbody_masked_rect;
> 						upbody = upbody_t;
> 						upbody.x = upbody.x + box.x;
> 						upbody.y = upbody.y + box.y;
> 						upbody &= cv::Rect(0, 0, Img.cols, Img.rows);
> 					}	
> 				}
> 			}
> 			
> 		}
> 		vector_to_json_t(r, upbody, is_up_body, isrect, str);	
> 
> 		//***************è°ƒè¯•****************
> 		if (atoi(ctx->cfg_->get_value("debug", "0")) > 0) 
> 		{
> 			for (int i = 0; i<r.size(); i++) 
> 			{
> 				rectangle(Img, r[i], Scalar(0, 0, 255), 2);
> 			}
> 
> 			for (int i = 0; i < first_r.size(); i++) 
> 			{
> 				cv::Rect box = ctx->detect_->masked_rect;
> 				first_r[i].x = first_r[i].x + box.x;
> 				first_r[i].y = first_r[i].y + box.y - 20;
> 				first_r[i].height = first_r[i].height + box.y + 40;
> 				first_r[i] &= cv::Rect(0, 0, Img.cols, Img.rows);
> 				rectangle(Img, first_r[i], Scalar(255, 0, 0), 2);
> 			}
> 
> 			rectangle(Img, upbody, Scalar(255, 255, 255), 2);
> 
> 			imshow("rawimage", Img);
> 			waitKey(1);
> 		}
> 			
> 	}
> 
> 	//***************************æ¿ä¹¦æ¢æµ‹****************************
> 	else if(ctx->b_m)
> 	{
> 		//åšæ©ç çš„åŸå§‹å›¾åƒ; 
> 		Mat masked_img = Mat(Img,ctx->bd_detect_->masked_rect);
> 		ctx->bd_detect_->do_mask(masked_img);
> 
> 		//ç›´æ¥è·å–æ ‡å®šåŒºå¤–æ¥çŸ©å½¢å›¾åƒ; 
> 		//ctx->bd_detect_->masked_rect &= Rect(0,0,img_t.cols, img_t.rows);	
> 		isrect = ctx->bd_detect_->one_frame_bd(&(IplImage)masked_img, r);
> 		for (int i = 0; i<r.size( ); i++) 
> 		{
> 			cv::Rect box = ctx->bd_detect_->masked_rect;
> 			r[i].x = r[i].x+box.x;
> 			r[i].y = r[i].y+box.y;
> 			r[i] &= cv::Rect(0,0,Img.cols,Img.rows);
> 		}
> 
> 		//***************è°ƒè¯•****************
> 		if (atoi(ctx->cfg_->get_value("debug", "0")) > 0) 
> 		{
> 			for (int i = 0; i < r.size(); i++) 
> 			{
> 				rectangle(Img, r[i], Scalar(0, 0, 255), 2);
> 			}
> 			//imshow("rawimage", Img);
> 			imshow("masked_img", masked_img);
> 			waitKey(1);
> 		}
> 
> 		if (isrect) 
> 		{
> 			bool cal1 = false; bool cal2 = false;
> 			for(int i = 0; i < r.size( ); i++)
> 			{
> 				cv::Point p = Point((r[i].x + r[i].width/2), (r[i].y + r[i].height/2));
> 				for(int j = 0; j < ctx->bd_detect_->masked_rect_vec.size( ); j++)
> 				{
> 					cv::Rect rect = ctx->bd_detect_->masked_rect_vec[j];
> 					if(p.x >= rect.x && p.x <= (rect.x+rect.width))
> 					{
> 						if(j == 0) cal1 = true;
> 						else if(j == 1) cal2 = true;
> 					}
> 				}
> 			}
> 			int area = 0;
> 			if(cal1 == true && cal2 == true) area = 0;
> 			else if(cal1 == true) area = 1;
> 			else if(cal2 == true) area = 2;
> 			else area = 0;
> 			vector_to_json(r, str, area);
> 		}
> 		else 
> 		{
> 			snprintf(str, BUFSIZE, "{\"stamp\": %d,\"area\":0,\"rect\": [ ] }", time(0));
> 		}
> 
> 	}
> 
> 	ctx->result_str = str;
> 	//return (char*)ctx->result_str.c_str( );
> 	return str;
diff libdetect_t_bak/libdetect_t.h libdetect_t_bak2/libdetect_t.h
5,11c5
< #include<opencv2/opencv1.hpp>
< #include "detect_t.h"
< #include "blackboard_detect.h"
< #include "StudentTrack.h"
< //#include "../libimagesource/image_source.h"
< #include <string>
< #include "hog.h"
---
> #include<opencv2/opencv.hpp>
17,39d10
< struct zifImage
< {
<     int fmt_type;
<     int width;
<     int height;
<     unsigned char *data[4];
<     int stride[4];
< };
< 
< struct det_t
< {
< 	KVConfig *cfg_;
< 	TeacherDetecting *detect_;
< 	BlackboardDetecting *bd_detect_;
<     CStudentTrack *stu_detect_;
< 	zk_hog_detector *hog_det;
< 	IplImage *masked_;
< 	bool t_m;
< 	bool b_m;
<     bool s_m;
< 	std::string result_str;	// FIXME: Ï£Íû×ã¹»ÁË;
< };
< 
42c13
< /** ·µ»ØÊµÀı
---
> /** ·µ»ØÊµÀı 
51c22
< /**
---
> /** 
53c24
< 	@return  ,json¸ñÊ½--   {"stamp":12345,"rect":[{"x":0,"y":0,"width":100,"height":100},{"x":0,"y":0,"width":100,"height":100}]}
---
> 	@return  ,json¸ñÊ½--   {"stamp":12345,"rect":[{"x":0,"y":0,"width":100,"height":100},{"x":0,"y":0,"width":100,"height":100}]}   
68,69c39,40
< //char *det_detect(det_t *ctx, zifImage *img);
< char *det_detect(det_t *ctx, cv::Mat &img);
---
> char *det_detect(det_t *ctx, zifImage *img);
> //char *det_detect(det_t *ctx, cv::Mat img);
80c51
< #endif
---
> #endif
\ æ–‡ä»¶å°¾æ²¡æœ‰ newline å­—ç¬¦
åªåœ¨ libdetect_t_bak å­˜åœ¨ï¼šlibdetect_t.o
diff libdetect_t_bak/libdetect_t.vcxproj libdetect_t_bak2/libdetect_t.vcxproj
2c2
< <Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
---
> <Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
7a8,11
>     <ProjectConfiguration Include="Debug|x64">
>       <Configuration>Debug</Configuration>
>       <Platform>x64</Platform>
>     </ProjectConfiguration>
11a16,19
>     <ProjectConfiguration Include="Release|x64">
>       <Configuration>Release</Configuration>
>       <Platform>x64</Platform>
>     </ProjectConfiguration>
23c31,37
<     <PlatformToolset>v90</PlatformToolset>
---
>     <PlatformToolset>v120</PlatformToolset>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
>     <ConfigurationType>DynamicLibrary</ConfigurationType>
>     <UseDebugLibraries>true</UseDebugLibraries>
>     <CharacterSet>Unicode</CharacterSet>
>     <PlatformToolset>v120</PlatformToolset>
31c45,53
<     <PlatformToolset>v100</PlatformToolset>
---
>     <PlatformToolset>v120</PlatformToolset>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
>     <ConfigurationType>DynamicLibrary</ConfigurationType>
>     <UseDebugLibraries>false</UseDebugLibraries>
>     <WholeProgramOptimization>true</WholeProgramOptimization>
>     <CharacterSet>Unicode</CharacterSet>
>     <UseOfMfc>false</UseOfMfc>
>     <PlatformToolset>v120</PlatformToolset>
38a61,63
>   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
41a67,69
>   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
50a79,86
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
>     <LinkIncremental>true</LinkIncremental>
>     <IncludePath>../../runtime/include;$(IncludePath)</IncludePath>
>     <LibraryPath>../../runtime/lib;$(LibraryPath)</LibraryPath>
>     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
>     <CodeAnalysisRules />
>     <CodeAnalysisRuleAssemblies />
>   </PropertyGroup>
58a95,102
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
>     <LinkIncremental>false</LinkIncremental>
>     <IncludePath>../../runtime64/include;$(IncludePath)</IncludePath>
>     <LibraryPath>../../runtime64/lib;$(LibraryPath)</LibraryPath>
>     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
>     <CodeAnalysisRules />
>     <CodeAnalysisRuleAssemblies />
>   </PropertyGroup>
74a119,134
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
>     <ClCompile>
>       <PrecompiledHeader>
>       </PrecompiledHeader>
>       <WarningLevel>Level3</WarningLevel>
>       <Optimization>Disabled</Optimization>
>       <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBDETECT_T_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
>     </ClCompile>
>     <Link>
>       <SubSystem>Windows</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>       <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
>       <AdditionalDependencies>ws2_32.lib;ccgnu2.lib;opencv_core249.lib;opencv_highgui249.lib;opencv_video249.lib;opencv_imgproc249.lib;opencv_objdetect249.lib;avcodec.lib;avutil.lib;swscale.lib;zqpsrv.lib;%(AdditionalDependencies)</AdditionalDependencies>
>     </Link>
>   </ItemDefinitionGroup>
95a156,175
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
>     <ClCompile>
>       <WarningLevel>Level3</WarningLevel>
>       <PrecompiledHeader>
>       </PrecompiledHeader>
>       <Optimization>MaxSpeed</Optimization>
>       <FunctionLevelLinking>true</FunctionLevelLinking>
>       <IntrinsicFunctions>true</IntrinsicFunctions>
>       <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBDETECT_T_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
>     </ClCompile>
>     <Link>
>       <SubSystem>Windows</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>       <EnableCOMDATFolding>true</EnableCOMDATFolding>
>       <OptimizeReferences>true</OptimizeReferences>
>       <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
>       <AdditionalDependencies>ws2_32.lib;ccgnu2.lib;opencv_core2412.lib;opencv_highgui2412.lib;opencv_video2412.lib;opencv_imgproc2412.lib;opencv_objdetect2412.lib;avcodec.lib;avutil.lib;swscale.lib;%(AdditionalDependencies)</AdditionalDependencies>
>     </Link>
>   </ItemDefinitionGroup>
120c200
<     <ProjectReference Include="..\..\..\image_trace\image_trace\libkvconfig\libkvconfig.vcxproj">
---
>     <ProjectReference Include="..\libkvconfig\libkvconfig.vcxproj">
åªåœ¨ libdetect_t_bak å­˜åœ¨ï¼šlibdetect_t.vcxproj.user
åªåœ¨ libdetect_t_bak å­˜åœ¨ï¼šMakefile
